// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FRCommonModelProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_FRCommonModelProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_FRCommonModelProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_FRCommonModelProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_FRCommonModelProto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_FRCommonModelProto_2eproto;
namespace DJIFRProto {
namespace Standard {
class Attitude;
struct AttitudeDefaultTypeInternal;
extern AttitudeDefaultTypeInternal _Attitude_default_instance_;
class GPSSignal;
struct GPSSignalDefaultTypeInternal;
extern GPSSignalDefaultTypeInternal _GPSSignal_default_instance_;
class LocationCoordinate2D;
struct LocationCoordinate2DDefaultTypeInternal;
extern LocationCoordinate2DDefaultTypeInternal _LocationCoordinate2D_default_instance_;
class SDK;
struct SDKDefaultTypeInternal;
extern SDKDefaultTypeInternal _SDK_default_instance_;
class Velocity;
struct VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
}  // namespace Standard
}  // namespace DJIFRProto
PROTOBUF_NAMESPACE_OPEN
template<> ::DJIFRProto::Standard::Attitude* Arena::CreateMaybeMessage<::DJIFRProto::Standard::Attitude>(Arena*);
template<> ::DJIFRProto::Standard::GPSSignal* Arena::CreateMaybeMessage<::DJIFRProto::Standard::GPSSignal>(Arena*);
template<> ::DJIFRProto::Standard::LocationCoordinate2D* Arena::CreateMaybeMessage<::DJIFRProto::Standard::LocationCoordinate2D>(Arena*);
template<> ::DJIFRProto::Standard::SDK* Arena::CreateMaybeMessage<::DJIFRProto::Standard::SDK>(Arena*);
template<> ::DJIFRProto::Standard::Velocity* Arena::CreateMaybeMessage<::DJIFRProto::Standard::Velocity>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DJIFRProto {
namespace Standard {

enum GPSSignal_Level : int {
  GPSSignal_Level_Level0 = 0,
  GPSSignal_Level_Level1 = 1,
  GPSSignal_Level_Level2 = 2,
  GPSSignal_Level_Level3 = 3,
  GPSSignal_Level_Level4 = 4,
  GPSSignal_Level_Level5 = 5,
  GPSSignal_Level_Unknown = 6,
  GPSSignal_Level_GPSSignal_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GPSSignal_Level_GPSSignal_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GPSSignal_Level_IsValid(int value);
constexpr GPSSignal_Level GPSSignal_Level_Level_MIN = GPSSignal_Level_Level0;
constexpr GPSSignal_Level GPSSignal_Level_Level_MAX = GPSSignal_Level_Unknown;
constexpr int GPSSignal_Level_Level_ARRAYSIZE = GPSSignal_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GPSSignal_Level_descriptor();
template<typename T>
inline const std::string& GPSSignal_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GPSSignal_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GPSSignal_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GPSSignal_Level_descriptor(), enum_t_value);
}
inline bool GPSSignal_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPSSignal_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GPSSignal_Level>(
    GPSSignal_Level_descriptor(), name, value);
}
enum SDK_ProductType : int {
  SDK_ProductType_None = 0,
  SDK_ProductType_ZUYdiVOVXfGCLDcI = 1,
  SDK_ProductType_Phantom3Standard = 2,
  SDK_ProductType_jwtAbyahuARrhuhr = 3,
  SDK_ProductType_kshQeTGrEeTmtpoe = 4,
  SDK_ProductType_Phantom4 = 7,
  SDK_ProductType_qvMmdCGxrtrJWvxx = 8,
  SDK_ProductType_CdogAypKribEXKfS = 9,
  SDK_ProductType_Matrice600 = 11,
  SDK_ProductType_Phantom34K = 12,
  SDK_ProductType_MavicPro = 13,
  SDK_ProductType_Inspire2 = 17,
  SDK_ProductType_Phantom4Pro = 24,
  SDK_ProductType_Spark = 26,
  SDK_ProductType_Matrice600Pro = 27,
  SDK_ProductType_Phantom4Advanced = 28,
  SDK_ProductType_Phantom3SE = 29,
  SDK_ProductType_Matrice200 = 31,
  SDK_ProductType_Matrice210 = 33,
  SDK_ProductType_Matrice210RTK = 34,
  SDK_ProductType_MavicAir = 38,
  SDK_ProductType_Mavic2 = 42,
  SDK_ProductType_Phantom4ProV2 = 44,
  SDK_ProductType_Phantom4RTK = 46,
  SDK_ProductType_P4Multispectral = 57,
  SDK_ProductType_Mavic2Enterprise = 58,
  SDK_ProductType_MavicMini = 59,
  SDK_ProductType_Matrice200V2 = 60,
  SDK_ProductType_Matrice210V2 = 61,
  SDK_ProductType_Matrice210RTKV2 = 62,
  SDK_ProductType_MavicAir2 = 67,
  SDK_ProductType_Matrice300RTK = 70,
  SDK_ProductType_DJIFPV = 73,
  SDK_ProductType_MavicAir2S = 75,
  SDK_ProductType_MavicMini2 = 76,
  SDK_ProductType_Mavic3 = 77,
  SDK_ProductType_MavicMiniSE = 96,
  SDK_ProductType_Matrice30 = 116,
  SDK_ProductType_SDK_ProductType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SDK_ProductType_SDK_ProductType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SDK_ProductType_IsValid(int value);
constexpr SDK_ProductType SDK_ProductType_ProductType_MIN = SDK_ProductType_None;
constexpr SDK_ProductType SDK_ProductType_ProductType_MAX = SDK_ProductType_Matrice30;
constexpr int SDK_ProductType_ProductType_ARRAYSIZE = SDK_ProductType_ProductType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SDK_ProductType_descriptor();
template<typename T>
inline const std::string& SDK_ProductType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SDK_ProductType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SDK_ProductType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SDK_ProductType_descriptor(), enum_t_value);
}
inline bool SDK_ProductType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SDK_ProductType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SDK_ProductType>(
    SDK_ProductType_descriptor(), name, value);
}
// ===================================================================

class LocationCoordinate2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.LocationCoordinate2D) */ {
 public:
  inline LocationCoordinate2D() : LocationCoordinate2D(nullptr) {}
  ~LocationCoordinate2D() override;
  explicit PROTOBUF_CONSTEXPR LocationCoordinate2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationCoordinate2D(const LocationCoordinate2D& from);
  LocationCoordinate2D(LocationCoordinate2D&& from) noexcept
    : LocationCoordinate2D() {
    *this = ::std::move(from);
  }

  inline LocationCoordinate2D& operator=(const LocationCoordinate2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationCoordinate2D& operator=(LocationCoordinate2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationCoordinate2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationCoordinate2D* internal_default_instance() {
    return reinterpret_cast<const LocationCoordinate2D*>(
               &_LocationCoordinate2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LocationCoordinate2D& a, LocationCoordinate2D& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationCoordinate2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationCoordinate2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationCoordinate2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationCoordinate2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationCoordinate2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationCoordinate2D& from) {
    LocationCoordinate2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationCoordinate2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.LocationCoordinate2D";
  }
  protected:
  explicit LocationCoordinate2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
  };
  // double latitude = 1;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 2;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.LocationCoordinate2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double latitude_;
    double longitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRCommonModelProto_2eproto;
};
// -------------------------------------------------------------------

class Velocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.Velocity) */ {
 public:
  inline Velocity() : Velocity(nullptr) {}
  ~Velocity() override;
  explicit PROTOBUF_CONSTEXPR Velocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Velocity(const Velocity& from);
  Velocity(Velocity&& from) noexcept
    : Velocity() {
    *this = ::std::move(from);
  }

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Velocity& operator=(Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Velocity* internal_default_instance() {
    return reinterpret_cast<const Velocity*>(
               &_Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Velocity& a, Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(Velocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Velocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Velocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Velocity& from) {
    Velocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Velocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.Velocity";
  }
  protected:
  explicit Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelocityXFieldNumber = 1,
    kVelocityYFieldNumber = 2,
    kVelocityZFieldNumber = 3,
  };
  // float velocityX = 1;
  void clear_velocityx();
  float velocityx() const;
  void set_velocityx(float value);
  private:
  float _internal_velocityx() const;
  void _internal_set_velocityx(float value);
  public:

  // float velocityY = 2;
  void clear_velocityy();
  float velocityy() const;
  void set_velocityy(float value);
  private:
  float _internal_velocityy() const;
  void _internal_set_velocityy(float value);
  public:

  // float velocityZ = 3;
  void clear_velocityz();
  float velocityz() const;
  void set_velocityz(float value);
  private:
  float _internal_velocityz() const;
  void _internal_set_velocityz(float value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float velocityx_;
    float velocityy_;
    float velocityz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRCommonModelProto_2eproto;
};
// -------------------------------------------------------------------

class Attitude final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.Attitude) */ {
 public:
  inline Attitude() : Attitude(nullptr) {}
  ~Attitude() override;
  explicit PROTOBUF_CONSTEXPR Attitude(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attitude(const Attitude& from);
  Attitude(Attitude&& from) noexcept
    : Attitude() {
    *this = ::std::move(from);
  }

  inline Attitude& operator=(const Attitude& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attitude& operator=(Attitude&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attitude& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attitude* internal_default_instance() {
    return reinterpret_cast<const Attitude*>(
               &_Attitude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Attitude& a, Attitude& b) {
    a.Swap(&b);
  }
  inline void Swap(Attitude* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attitude* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attitude* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attitude>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attitude& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attitude& from) {
    Attitude::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attitude* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.Attitude";
  }
  protected:
  explicit Attitude(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
    kRollFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // double pitch = 1;
  void clear_pitch();
  double pitch() const;
  void set_pitch(double value);
  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);
  public:

  // double roll = 2;
  void clear_roll();
  double roll() const;
  void set_roll(double value);
  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);
  public:

  // double yaw = 3;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.Attitude)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double pitch_;
    double roll_;
    double yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRCommonModelProto_2eproto;
};
// -------------------------------------------------------------------

class GPSSignal final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.GPSSignal) */ {
 public:
  inline GPSSignal() : GPSSignal(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GPSSignal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPSSignal(const GPSSignal& from);
  GPSSignal(GPSSignal&& from) noexcept
    : GPSSignal() {
    *this = ::std::move(from);
  }

  inline GPSSignal& operator=(const GPSSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPSSignal& operator=(GPSSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPSSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPSSignal* internal_default_instance() {
    return reinterpret_cast<const GPSSignal*>(
               &_GPSSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GPSSignal& a, GPSSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(GPSSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPSSignal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GPSSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GPSSignal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GPSSignal& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GPSSignal& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.GPSSignal";
  }
  protected:
  explicit GPSSignal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GPSSignal_Level Level;
  static constexpr Level Level0 =
    GPSSignal_Level_Level0;
  static constexpr Level Level1 =
    GPSSignal_Level_Level1;
  static constexpr Level Level2 =
    GPSSignal_Level_Level2;
  static constexpr Level Level3 =
    GPSSignal_Level_Level3;
  static constexpr Level Level4 =
    GPSSignal_Level_Level4;
  static constexpr Level Level5 =
    GPSSignal_Level_Level5;
  static constexpr Level Unknown =
    GPSSignal_Level_Unknown;
  static inline bool Level_IsValid(int value) {
    return GPSSignal_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    GPSSignal_Level_Level_MIN;
  static constexpr Level Level_MAX =
    GPSSignal_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    GPSSignal_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return GPSSignal_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return GPSSignal_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return GPSSignal_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.GPSSignal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRCommonModelProto_2eproto;
};
// -------------------------------------------------------------------

class SDK final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.SDK) */ {
 public:
  inline SDK() : SDK(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SDK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SDK(const SDK& from);
  SDK(SDK&& from) noexcept
    : SDK() {
    *this = ::std::move(from);
  }

  inline SDK& operator=(const SDK& from) {
    CopyFrom(from);
    return *this;
  }
  inline SDK& operator=(SDK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SDK& default_instance() {
    return *internal_default_instance();
  }
  static inline const SDK* internal_default_instance() {
    return reinterpret_cast<const SDK*>(
               &_SDK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SDK& a, SDK& b) {
    a.Swap(&b);
  }
  inline void Swap(SDK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SDK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SDK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SDK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SDK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SDK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.SDK";
  }
  protected:
  explicit SDK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SDK_ProductType ProductType;
  static constexpr ProductType None =
    SDK_ProductType_None;
  static constexpr ProductType ZUYdiVOVXfGCLDcI =
    SDK_ProductType_ZUYdiVOVXfGCLDcI;
  static constexpr ProductType Phantom3Standard =
    SDK_ProductType_Phantom3Standard;
  static constexpr ProductType jwtAbyahuARrhuhr =
    SDK_ProductType_jwtAbyahuARrhuhr;
  static constexpr ProductType kshQeTGrEeTmtpoe =
    SDK_ProductType_kshQeTGrEeTmtpoe;
  static constexpr ProductType Phantom4 =
    SDK_ProductType_Phantom4;
  static constexpr ProductType qvMmdCGxrtrJWvxx =
    SDK_ProductType_qvMmdCGxrtrJWvxx;
  static constexpr ProductType CdogAypKribEXKfS =
    SDK_ProductType_CdogAypKribEXKfS;
  static constexpr ProductType Matrice600 =
    SDK_ProductType_Matrice600;
  static constexpr ProductType Phantom34K =
    SDK_ProductType_Phantom34K;
  static constexpr ProductType MavicPro =
    SDK_ProductType_MavicPro;
  static constexpr ProductType Inspire2 =
    SDK_ProductType_Inspire2;
  static constexpr ProductType Phantom4Pro =
    SDK_ProductType_Phantom4Pro;
  static constexpr ProductType Spark =
    SDK_ProductType_Spark;
  static constexpr ProductType Matrice600Pro =
    SDK_ProductType_Matrice600Pro;
  static constexpr ProductType Phantom4Advanced =
    SDK_ProductType_Phantom4Advanced;
  static constexpr ProductType Phantom3SE =
    SDK_ProductType_Phantom3SE;
  static constexpr ProductType Matrice200 =
    SDK_ProductType_Matrice200;
  static constexpr ProductType Matrice210 =
    SDK_ProductType_Matrice210;
  static constexpr ProductType Matrice210RTK =
    SDK_ProductType_Matrice210RTK;
  static constexpr ProductType MavicAir =
    SDK_ProductType_MavicAir;
  static constexpr ProductType Mavic2 =
    SDK_ProductType_Mavic2;
  static constexpr ProductType Phantom4ProV2 =
    SDK_ProductType_Phantom4ProV2;
  static constexpr ProductType Phantom4RTK =
    SDK_ProductType_Phantom4RTK;
  static constexpr ProductType P4Multispectral =
    SDK_ProductType_P4Multispectral;
  static constexpr ProductType Mavic2Enterprise =
    SDK_ProductType_Mavic2Enterprise;
  static constexpr ProductType MavicMini =
    SDK_ProductType_MavicMini;
  static constexpr ProductType Matrice200V2 =
    SDK_ProductType_Matrice200V2;
  static constexpr ProductType Matrice210V2 =
    SDK_ProductType_Matrice210V2;
  static constexpr ProductType Matrice210RTKV2 =
    SDK_ProductType_Matrice210RTKV2;
  static constexpr ProductType MavicAir2 =
    SDK_ProductType_MavicAir2;
  static constexpr ProductType Matrice300RTK =
    SDK_ProductType_Matrice300RTK;
  static constexpr ProductType DJIFPV =
    SDK_ProductType_DJIFPV;
  static constexpr ProductType MavicAir2S =
    SDK_ProductType_MavicAir2S;
  static constexpr ProductType MavicMini2 =
    SDK_ProductType_MavicMini2;
  static constexpr ProductType Mavic3 =
    SDK_ProductType_Mavic3;
  static constexpr ProductType MavicMiniSE =
    SDK_ProductType_MavicMiniSE;
  static constexpr ProductType Matrice30 =
    SDK_ProductType_Matrice30;
  static inline bool ProductType_IsValid(int value) {
    return SDK_ProductType_IsValid(value);
  }
  static constexpr ProductType ProductType_MIN =
    SDK_ProductType_ProductType_MIN;
  static constexpr ProductType ProductType_MAX =
    SDK_ProductType_ProductType_MAX;
  static constexpr int ProductType_ARRAYSIZE =
    SDK_ProductType_ProductType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProductType_descriptor() {
    return SDK_ProductType_descriptor();
  }
  template<typename T>
  static inline const std::string& ProductType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProductType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProductType_Name.");
    return SDK_ProductType_Name(enum_t_value);
  }
  static inline bool ProductType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProductType* value) {
    return SDK_ProductType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.SDK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRCommonModelProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LocationCoordinate2D

// double latitude = 1;
inline void LocationCoordinate2D::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline double LocationCoordinate2D::_internal_latitude() const {
  return _impl_.latitude_;
}
inline double LocationCoordinate2D::latitude() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.LocationCoordinate2D.latitude)
  return _internal_latitude();
}
inline void LocationCoordinate2D::_internal_set_latitude(double value) {
  
  _impl_.latitude_ = value;
}
inline void LocationCoordinate2D::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.LocationCoordinate2D.latitude)
}

// double longitude = 2;
inline void LocationCoordinate2D::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline double LocationCoordinate2D::_internal_longitude() const {
  return _impl_.longitude_;
}
inline double LocationCoordinate2D::longitude() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.LocationCoordinate2D.longitude)
  return _internal_longitude();
}
inline void LocationCoordinate2D::_internal_set_longitude(double value) {
  
  _impl_.longitude_ = value;
}
inline void LocationCoordinate2D::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.LocationCoordinate2D.longitude)
}

// -------------------------------------------------------------------

// Velocity

// float velocityX = 1;
inline void Velocity::clear_velocityx() {
  _impl_.velocityx_ = 0;
}
inline float Velocity::_internal_velocityx() const {
  return _impl_.velocityx_;
}
inline float Velocity::velocityx() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.Velocity.velocityX)
  return _internal_velocityx();
}
inline void Velocity::_internal_set_velocityx(float value) {
  
  _impl_.velocityx_ = value;
}
inline void Velocity::set_velocityx(float value) {
  _internal_set_velocityx(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.Velocity.velocityX)
}

// float velocityY = 2;
inline void Velocity::clear_velocityy() {
  _impl_.velocityy_ = 0;
}
inline float Velocity::_internal_velocityy() const {
  return _impl_.velocityy_;
}
inline float Velocity::velocityy() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.Velocity.velocityY)
  return _internal_velocityy();
}
inline void Velocity::_internal_set_velocityy(float value) {
  
  _impl_.velocityy_ = value;
}
inline void Velocity::set_velocityy(float value) {
  _internal_set_velocityy(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.Velocity.velocityY)
}

// float velocityZ = 3;
inline void Velocity::clear_velocityz() {
  _impl_.velocityz_ = 0;
}
inline float Velocity::_internal_velocityz() const {
  return _impl_.velocityz_;
}
inline float Velocity::velocityz() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.Velocity.velocityZ)
  return _internal_velocityz();
}
inline void Velocity::_internal_set_velocityz(float value) {
  
  _impl_.velocityz_ = value;
}
inline void Velocity::set_velocityz(float value) {
  _internal_set_velocityz(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.Velocity.velocityZ)
}

// -------------------------------------------------------------------

// Attitude

// double pitch = 1;
inline void Attitude::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline double Attitude::_internal_pitch() const {
  return _impl_.pitch_;
}
inline double Attitude::pitch() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.Attitude.pitch)
  return _internal_pitch();
}
inline void Attitude::_internal_set_pitch(double value) {
  
  _impl_.pitch_ = value;
}
inline void Attitude::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.Attitude.pitch)
}

// double roll = 2;
inline void Attitude::clear_roll() {
  _impl_.roll_ = 0;
}
inline double Attitude::_internal_roll() const {
  return _impl_.roll_;
}
inline double Attitude::roll() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.Attitude.roll)
  return _internal_roll();
}
inline void Attitude::_internal_set_roll(double value) {
  
  _impl_.roll_ = value;
}
inline void Attitude::set_roll(double value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.Attitude.roll)
}

// double yaw = 3;
inline void Attitude::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline double Attitude::_internal_yaw() const {
  return _impl_.yaw_;
}
inline double Attitude::yaw() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.Attitude.yaw)
  return _internal_yaw();
}
inline void Attitude::_internal_set_yaw(double value) {
  
  _impl_.yaw_ = value;
}
inline void Attitude::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.Attitude.yaw)
}

// -------------------------------------------------------------------

// GPSSignal

// -------------------------------------------------------------------

// SDK

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Standard
}  // namespace DJIFRProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DJIFRProto::Standard::GPSSignal_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::GPSSignal_Level>() {
  return ::DJIFRProto::Standard::GPSSignal_Level_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::SDK_ProductType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::SDK_ProductType>() {
  return ::DJIFRProto::Standard::SDK_ProductType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_FRCommonModelProto_2eproto
