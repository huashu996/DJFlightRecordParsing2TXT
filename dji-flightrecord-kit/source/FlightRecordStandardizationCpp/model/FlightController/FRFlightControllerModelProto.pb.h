// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FRFlightControllerModelProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_FRFlightControllerModelProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_FRFlightControllerModelProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FRCommonModelProto.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_FRFlightControllerModelProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_FRFlightControllerModelProto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_FRFlightControllerModelProto_2eproto;
namespace DJIFRProto {
namespace Standard {
class Connection;
struct ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class FlightControllerState;
struct FlightControllerStateDefaultTypeInternal;
extern FlightControllerStateDefaultTypeInternal _FlightControllerState_default_instance_;
class FlightWind;
struct FlightWindDefaultTypeInternal;
extern FlightWindDefaultTypeInternal _FlightWind_default_instance_;
class SmartRTH;
struct SmartRTHDefaultTypeInternal;
extern SmartRTHDefaultTypeInternal _SmartRTH_default_instance_;
class VirtualStickFlightControlData;
struct VirtualStickFlightControlDataDefaultTypeInternal;
extern VirtualStickFlightControlDataDefaultTypeInternal _VirtualStickFlightControlData_default_instance_;
class VirtualStickFlightCoordinate;
struct VirtualStickFlightCoordinateDefaultTypeInternal;
extern VirtualStickFlightCoordinateDefaultTypeInternal _VirtualStickFlightCoordinate_default_instance_;
class VirtualStickRollPitchControl;
struct VirtualStickRollPitchControlDefaultTypeInternal;
extern VirtualStickRollPitchControlDefaultTypeInternal _VirtualStickRollPitchControl_default_instance_;
class VirtualStickVerticalControl;
struct VirtualStickVerticalControlDefaultTypeInternal;
extern VirtualStickVerticalControlDefaultTypeInternal _VirtualStickVerticalControl_default_instance_;
class VirtualStickYawControl;
struct VirtualStickYawControlDefaultTypeInternal;
extern VirtualStickYawControlDefaultTypeInternal _VirtualStickYawControl_default_instance_;
}  // namespace Standard
}  // namespace DJIFRProto
PROTOBUF_NAMESPACE_OPEN
template<> ::DJIFRProto::Standard::Connection* Arena::CreateMaybeMessage<::DJIFRProto::Standard::Connection>(Arena*);
template<> ::DJIFRProto::Standard::FlightControllerState* Arena::CreateMaybeMessage<::DJIFRProto::Standard::FlightControllerState>(Arena*);
template<> ::DJIFRProto::Standard::FlightWind* Arena::CreateMaybeMessage<::DJIFRProto::Standard::FlightWind>(Arena*);
template<> ::DJIFRProto::Standard::SmartRTH* Arena::CreateMaybeMessage<::DJIFRProto::Standard::SmartRTH>(Arena*);
template<> ::DJIFRProto::Standard::VirtualStickFlightControlData* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VirtualStickFlightControlData>(Arena*);
template<> ::DJIFRProto::Standard::VirtualStickFlightCoordinate* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VirtualStickFlightCoordinate>(Arena*);
template<> ::DJIFRProto::Standard::VirtualStickRollPitchControl* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VirtualStickRollPitchControl>(Arena*);
template<> ::DJIFRProto::Standard::VirtualStickVerticalControl* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VirtualStickVerticalControl>(Arena*);
template<> ::DJIFRProto::Standard::VirtualStickYawControl* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VirtualStickYawControl>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DJIFRProto {
namespace Standard {

enum FlightWind_Warning : int {
  FlightWind_Warning_Level0 = 0,
  FlightWind_Warning_Level1 = 1,
  FlightWind_Warning_Level2 = 2,
  FlightWind_Warning_Unknown = 3,
  FlightWind_Warning_FlightWind_Warning_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FlightWind_Warning_FlightWind_Warning_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FlightWind_Warning_IsValid(int value);
constexpr FlightWind_Warning FlightWind_Warning_Warning_MIN = FlightWind_Warning_Level0;
constexpr FlightWind_Warning FlightWind_Warning_Warning_MAX = FlightWind_Warning_Unknown;
constexpr int FlightWind_Warning_Warning_ARRAYSIZE = FlightWind_Warning_Warning_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlightWind_Warning_descriptor();
template<typename T>
inline const std::string& FlightWind_Warning_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlightWind_Warning>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlightWind_Warning_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FlightWind_Warning_descriptor(), enum_t_value);
}
inline bool FlightWind_Warning_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlightWind_Warning* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlightWind_Warning>(
    FlightWind_Warning_descriptor(), name, value);
}
enum Connection_FailSafeBehavior : int {
  Connection_FailSafeBehavior_Hover = 0,
  Connection_FailSafeBehavior_Landing = 1,
  Connection_FailSafeBehavior_GoHome = 2,
  Connection_FailSafeBehavior_Unknown = 3,
  Connection_FailSafeBehavior_Connection_FailSafeBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Connection_FailSafeBehavior_Connection_FailSafeBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Connection_FailSafeBehavior_IsValid(int value);
constexpr Connection_FailSafeBehavior Connection_FailSafeBehavior_FailSafeBehavior_MIN = Connection_FailSafeBehavior_Hover;
constexpr Connection_FailSafeBehavior Connection_FailSafeBehavior_FailSafeBehavior_MAX = Connection_FailSafeBehavior_Unknown;
constexpr int Connection_FailSafeBehavior_FailSafeBehavior_ARRAYSIZE = Connection_FailSafeBehavior_FailSafeBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Connection_FailSafeBehavior_descriptor();
template<typename T>
inline const std::string& Connection_FailSafeBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Connection_FailSafeBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Connection_FailSafeBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Connection_FailSafeBehavior_descriptor(), enum_t_value);
}
inline bool Connection_FailSafeBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Connection_FailSafeBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Connection_FailSafeBehavior>(
    Connection_FailSafeBehavior_descriptor(), name, value);
}
enum SmartRTH_State : int {
  SmartRTH_State_Idle = 0,
  SmartRTH_State_CountingDown = 1,
  SmartRTH_State_Executed = 2,
  SmartRTH_State_Cancelled = 3,
  SmartRTH_State_Unknown = 4,
  SmartRTH_State_SmartRTH_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SmartRTH_State_SmartRTH_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SmartRTH_State_IsValid(int value);
constexpr SmartRTH_State SmartRTH_State_State_MIN = SmartRTH_State_Idle;
constexpr SmartRTH_State SmartRTH_State_State_MAX = SmartRTH_State_Unknown;
constexpr int SmartRTH_State_State_ARRAYSIZE = SmartRTH_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SmartRTH_State_descriptor();
template<typename T>
inline const std::string& SmartRTH_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SmartRTH_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SmartRTH_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SmartRTH_State_descriptor(), enum_t_value);
}
inline bool SmartRTH_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SmartRTH_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SmartRTH_State>(
    SmartRTH_State_descriptor(), name, value);
}
enum VirtualStickVerticalControl_Mode : int {
  VirtualStickVerticalControl_Mode_Velocity = 0,
  VirtualStickVerticalControl_Mode_Position = 1,
  VirtualStickVerticalControl_Mode_Unknown = 2,
  VirtualStickVerticalControl_Mode_VirtualStickVerticalControl_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VirtualStickVerticalControl_Mode_VirtualStickVerticalControl_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VirtualStickVerticalControl_Mode_IsValid(int value);
constexpr VirtualStickVerticalControl_Mode VirtualStickVerticalControl_Mode_Mode_MIN = VirtualStickVerticalControl_Mode_Velocity;
constexpr VirtualStickVerticalControl_Mode VirtualStickVerticalControl_Mode_Mode_MAX = VirtualStickVerticalControl_Mode_Unknown;
constexpr int VirtualStickVerticalControl_Mode_Mode_ARRAYSIZE = VirtualStickVerticalControl_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VirtualStickVerticalControl_Mode_descriptor();
template<typename T>
inline const std::string& VirtualStickVerticalControl_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VirtualStickVerticalControl_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VirtualStickVerticalControl_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VirtualStickVerticalControl_Mode_descriptor(), enum_t_value);
}
inline bool VirtualStickVerticalControl_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VirtualStickVerticalControl_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VirtualStickVerticalControl_Mode>(
    VirtualStickVerticalControl_Mode_descriptor(), name, value);
}
enum VirtualStickRollPitchControl_Mode : int {
  VirtualStickRollPitchControl_Mode_Angle = 0,
  VirtualStickRollPitchControl_Mode_Velocity = 1,
  VirtualStickRollPitchControl_Mode_Unknown = 2,
  VirtualStickRollPitchControl_Mode_VirtualStickRollPitchControl_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VirtualStickRollPitchControl_Mode_VirtualStickRollPitchControl_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VirtualStickRollPitchControl_Mode_IsValid(int value);
constexpr VirtualStickRollPitchControl_Mode VirtualStickRollPitchControl_Mode_Mode_MIN = VirtualStickRollPitchControl_Mode_Angle;
constexpr VirtualStickRollPitchControl_Mode VirtualStickRollPitchControl_Mode_Mode_MAX = VirtualStickRollPitchControl_Mode_Unknown;
constexpr int VirtualStickRollPitchControl_Mode_Mode_ARRAYSIZE = VirtualStickRollPitchControl_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VirtualStickRollPitchControl_Mode_descriptor();
template<typename T>
inline const std::string& VirtualStickRollPitchControl_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VirtualStickRollPitchControl_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VirtualStickRollPitchControl_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VirtualStickRollPitchControl_Mode_descriptor(), enum_t_value);
}
inline bool VirtualStickRollPitchControl_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VirtualStickRollPitchControl_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VirtualStickRollPitchControl_Mode>(
    VirtualStickRollPitchControl_Mode_descriptor(), name, value);
}
enum VirtualStickYawControl_Mode : int {
  VirtualStickYawControl_Mode_Angle = 0,
  VirtualStickYawControl_Mode_Velocity = 1,
  VirtualStickYawControl_Mode_Unknown = 2,
  VirtualStickYawControl_Mode_VirtualStickYawControl_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VirtualStickYawControl_Mode_VirtualStickYawControl_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VirtualStickYawControl_Mode_IsValid(int value);
constexpr VirtualStickYawControl_Mode VirtualStickYawControl_Mode_Mode_MIN = VirtualStickYawControl_Mode_Angle;
constexpr VirtualStickYawControl_Mode VirtualStickYawControl_Mode_Mode_MAX = VirtualStickYawControl_Mode_Unknown;
constexpr int VirtualStickYawControl_Mode_Mode_ARRAYSIZE = VirtualStickYawControl_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VirtualStickYawControl_Mode_descriptor();
template<typename T>
inline const std::string& VirtualStickYawControl_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VirtualStickYawControl_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VirtualStickYawControl_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VirtualStickYawControl_Mode_descriptor(), enum_t_value);
}
inline bool VirtualStickYawControl_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VirtualStickYawControl_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VirtualStickYawControl_Mode>(
    VirtualStickYawControl_Mode_descriptor(), name, value);
}
enum VirtualStickFlightCoordinate_System : int {
  VirtualStickFlightCoordinate_System_Ground = 0,
  VirtualStickFlightCoordinate_System_Body = 1,
  VirtualStickFlightCoordinate_System_Unknown = 2,
  VirtualStickFlightCoordinate_System_VirtualStickFlightCoordinate_System_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VirtualStickFlightCoordinate_System_VirtualStickFlightCoordinate_System_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VirtualStickFlightCoordinate_System_IsValid(int value);
constexpr VirtualStickFlightCoordinate_System VirtualStickFlightCoordinate_System_System_MIN = VirtualStickFlightCoordinate_System_Ground;
constexpr VirtualStickFlightCoordinate_System VirtualStickFlightCoordinate_System_System_MAX = VirtualStickFlightCoordinate_System_Unknown;
constexpr int VirtualStickFlightCoordinate_System_System_ARRAYSIZE = VirtualStickFlightCoordinate_System_System_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VirtualStickFlightCoordinate_System_descriptor();
template<typename T>
inline const std::string& VirtualStickFlightCoordinate_System_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VirtualStickFlightCoordinate_System>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VirtualStickFlightCoordinate_System_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VirtualStickFlightCoordinate_System_descriptor(), enum_t_value);
}
inline bool VirtualStickFlightCoordinate_System_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VirtualStickFlightCoordinate_System* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VirtualStickFlightCoordinate_System>(
    VirtualStickFlightCoordinate_System_descriptor(), name, value);
}
enum FlightMode : int {
  Manual = 0,
  Atti = 1,
  AttiCourseLock = 2,
  GPSAtti = 6,
  GPSCourseLock = 7,
  GPSHomeLock = 8,
  GPSHotPoint = 9,
  AssistedTakeoff = 10,
  AutoTakeoff = 11,
  AutoLanding = 12,
  GPSWaypoint = 14,
  GoHome = 15,
  Joystick = 17,
  GPSAttiWristband = 18,
  Draw = 24,
  GPSFollowMe = 25,
  ActiveTrack = 26,
  TapFly = 27,
  GPSSport = 31,
  GPSNovice = 32,
  ConfirmLanding = 33,
  TerrainFollow = 35,
  Tripod = 38,
  ActiveTrackSpotlight = 39,
  MotorsJustStarted = 41,
  Unknown = 255,
  FlightMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FlightMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FlightMode_IsValid(int value);
constexpr FlightMode FlightMode_MIN = Manual;
constexpr FlightMode FlightMode_MAX = Unknown;
constexpr int FlightMode_ARRAYSIZE = FlightMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlightMode_descriptor();
template<typename T>
inline const std::string& FlightMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlightMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlightMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FlightMode_descriptor(), enum_t_value);
}
inline bool FlightMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlightMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlightMode>(
    FlightMode_descriptor(), name, value);
}
// ===================================================================

class FlightWind final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.FlightWind) */ {
 public:
  inline FlightWind() : FlightWind(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FlightWind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightWind(const FlightWind& from);
  FlightWind(FlightWind&& from) noexcept
    : FlightWind() {
    *this = ::std::move(from);
  }

  inline FlightWind& operator=(const FlightWind& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightWind& operator=(FlightWind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightWind& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightWind* internal_default_instance() {
    return reinterpret_cast<const FlightWind*>(
               &_FlightWind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FlightWind& a, FlightWind& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightWind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightWind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightWind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightWind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlightWind& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlightWind& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.FlightWind";
  }
  protected:
  explicit FlightWind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlightWind_Warning Warning;
  static constexpr Warning Level0 =
    FlightWind_Warning_Level0;
  static constexpr Warning Level1 =
    FlightWind_Warning_Level1;
  static constexpr Warning Level2 =
    FlightWind_Warning_Level2;
  static constexpr Warning Unknown =
    FlightWind_Warning_Unknown;
  static inline bool Warning_IsValid(int value) {
    return FlightWind_Warning_IsValid(value);
  }
  static constexpr Warning Warning_MIN =
    FlightWind_Warning_Warning_MIN;
  static constexpr Warning Warning_MAX =
    FlightWind_Warning_Warning_MAX;
  static constexpr int Warning_ARRAYSIZE =
    FlightWind_Warning_Warning_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Warning_descriptor() {
    return FlightWind_Warning_descriptor();
  }
  template<typename T>
  static inline const std::string& Warning_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Warning>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Warning_Name.");
    return FlightWind_Warning_Name(enum_t_value);
  }
  static inline bool Warning_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Warning* value) {
    return FlightWind_Warning_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.FlightWind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class Connection final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Connection& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Connection& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Connection_FailSafeBehavior FailSafeBehavior;
  static constexpr FailSafeBehavior Hover =
    Connection_FailSafeBehavior_Hover;
  static constexpr FailSafeBehavior Landing =
    Connection_FailSafeBehavior_Landing;
  static constexpr FailSafeBehavior GoHome =
    Connection_FailSafeBehavior_GoHome;
  static constexpr FailSafeBehavior Unknown =
    Connection_FailSafeBehavior_Unknown;
  static inline bool FailSafeBehavior_IsValid(int value) {
    return Connection_FailSafeBehavior_IsValid(value);
  }
  static constexpr FailSafeBehavior FailSafeBehavior_MIN =
    Connection_FailSafeBehavior_FailSafeBehavior_MIN;
  static constexpr FailSafeBehavior FailSafeBehavior_MAX =
    Connection_FailSafeBehavior_FailSafeBehavior_MAX;
  static constexpr int FailSafeBehavior_ARRAYSIZE =
    Connection_FailSafeBehavior_FailSafeBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FailSafeBehavior_descriptor() {
    return Connection_FailSafeBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& FailSafeBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FailSafeBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FailSafeBehavior_Name.");
    return Connection_FailSafeBehavior_Name(enum_t_value);
  }
  static inline bool FailSafeBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FailSafeBehavior* value) {
    return Connection_FailSafeBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class SmartRTH final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.SmartRTH) */ {
 public:
  inline SmartRTH() : SmartRTH(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SmartRTH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartRTH(const SmartRTH& from);
  SmartRTH(SmartRTH&& from) noexcept
    : SmartRTH() {
    *this = ::std::move(from);
  }

  inline SmartRTH& operator=(const SmartRTH& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartRTH& operator=(SmartRTH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartRTH& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartRTH* internal_default_instance() {
    return reinterpret_cast<const SmartRTH*>(
               &_SmartRTH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SmartRTH& a, SmartRTH& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartRTH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartRTH* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartRTH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartRTH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SmartRTH& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SmartRTH& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.SmartRTH";
  }
  protected:
  explicit SmartRTH(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SmartRTH_State State;
  static constexpr State Idle =
    SmartRTH_State_Idle;
  static constexpr State CountingDown =
    SmartRTH_State_CountingDown;
  static constexpr State Executed =
    SmartRTH_State_Executed;
  static constexpr State Cancelled =
    SmartRTH_State_Cancelled;
  static constexpr State Unknown =
    SmartRTH_State_Unknown;
  static inline bool State_IsValid(int value) {
    return SmartRTH_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SmartRTH_State_State_MIN;
  static constexpr State State_MAX =
    SmartRTH_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SmartRTH_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SmartRTH_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SmartRTH_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SmartRTH_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.SmartRTH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class VirtualStickVerticalControl final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VirtualStickVerticalControl) */ {
 public:
  inline VirtualStickVerticalControl() : VirtualStickVerticalControl(nullptr) {}
  explicit PROTOBUF_CONSTEXPR VirtualStickVerticalControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualStickVerticalControl(const VirtualStickVerticalControl& from);
  VirtualStickVerticalControl(VirtualStickVerticalControl&& from) noexcept
    : VirtualStickVerticalControl() {
    *this = ::std::move(from);
  }

  inline VirtualStickVerticalControl& operator=(const VirtualStickVerticalControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualStickVerticalControl& operator=(VirtualStickVerticalControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualStickVerticalControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualStickVerticalControl* internal_default_instance() {
    return reinterpret_cast<const VirtualStickVerticalControl*>(
               &_VirtualStickVerticalControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VirtualStickVerticalControl& a, VirtualStickVerticalControl& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualStickVerticalControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualStickVerticalControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualStickVerticalControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualStickVerticalControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VirtualStickVerticalControl& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VirtualStickVerticalControl& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VirtualStickVerticalControl";
  }
  protected:
  explicit VirtualStickVerticalControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VirtualStickVerticalControl_Mode Mode;
  static constexpr Mode Velocity =
    VirtualStickVerticalControl_Mode_Velocity;
  static constexpr Mode Position =
    VirtualStickVerticalControl_Mode_Position;
  static constexpr Mode Unknown =
    VirtualStickVerticalControl_Mode_Unknown;
  static inline bool Mode_IsValid(int value) {
    return VirtualStickVerticalControl_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    VirtualStickVerticalControl_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    VirtualStickVerticalControl_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    VirtualStickVerticalControl_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return VirtualStickVerticalControl_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return VirtualStickVerticalControl_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return VirtualStickVerticalControl_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VirtualStickVerticalControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class VirtualStickRollPitchControl final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VirtualStickRollPitchControl) */ {
 public:
  inline VirtualStickRollPitchControl() : VirtualStickRollPitchControl(nullptr) {}
  explicit PROTOBUF_CONSTEXPR VirtualStickRollPitchControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualStickRollPitchControl(const VirtualStickRollPitchControl& from);
  VirtualStickRollPitchControl(VirtualStickRollPitchControl&& from) noexcept
    : VirtualStickRollPitchControl() {
    *this = ::std::move(from);
  }

  inline VirtualStickRollPitchControl& operator=(const VirtualStickRollPitchControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualStickRollPitchControl& operator=(VirtualStickRollPitchControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualStickRollPitchControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualStickRollPitchControl* internal_default_instance() {
    return reinterpret_cast<const VirtualStickRollPitchControl*>(
               &_VirtualStickRollPitchControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VirtualStickRollPitchControl& a, VirtualStickRollPitchControl& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualStickRollPitchControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualStickRollPitchControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualStickRollPitchControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualStickRollPitchControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VirtualStickRollPitchControl& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VirtualStickRollPitchControl& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VirtualStickRollPitchControl";
  }
  protected:
  explicit VirtualStickRollPitchControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VirtualStickRollPitchControl_Mode Mode;
  static constexpr Mode Angle =
    VirtualStickRollPitchControl_Mode_Angle;
  static constexpr Mode Velocity =
    VirtualStickRollPitchControl_Mode_Velocity;
  static constexpr Mode Unknown =
    VirtualStickRollPitchControl_Mode_Unknown;
  static inline bool Mode_IsValid(int value) {
    return VirtualStickRollPitchControl_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    VirtualStickRollPitchControl_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    VirtualStickRollPitchControl_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    VirtualStickRollPitchControl_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return VirtualStickRollPitchControl_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return VirtualStickRollPitchControl_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return VirtualStickRollPitchControl_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VirtualStickRollPitchControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class VirtualStickYawControl final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VirtualStickYawControl) */ {
 public:
  inline VirtualStickYawControl() : VirtualStickYawControl(nullptr) {}
  explicit PROTOBUF_CONSTEXPR VirtualStickYawControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualStickYawControl(const VirtualStickYawControl& from);
  VirtualStickYawControl(VirtualStickYawControl&& from) noexcept
    : VirtualStickYawControl() {
    *this = ::std::move(from);
  }

  inline VirtualStickYawControl& operator=(const VirtualStickYawControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualStickYawControl& operator=(VirtualStickYawControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualStickYawControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualStickYawControl* internal_default_instance() {
    return reinterpret_cast<const VirtualStickYawControl*>(
               &_VirtualStickYawControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VirtualStickYawControl& a, VirtualStickYawControl& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualStickYawControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualStickYawControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualStickYawControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualStickYawControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VirtualStickYawControl& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VirtualStickYawControl& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VirtualStickYawControl";
  }
  protected:
  explicit VirtualStickYawControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VirtualStickYawControl_Mode Mode;
  static constexpr Mode Angle =
    VirtualStickYawControl_Mode_Angle;
  static constexpr Mode Velocity =
    VirtualStickYawControl_Mode_Velocity;
  static constexpr Mode Unknown =
    VirtualStickYawControl_Mode_Unknown;
  static inline bool Mode_IsValid(int value) {
    return VirtualStickYawControl_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    VirtualStickYawControl_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    VirtualStickYawControl_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    VirtualStickYawControl_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return VirtualStickYawControl_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return VirtualStickYawControl_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return VirtualStickYawControl_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VirtualStickYawControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class VirtualStickFlightCoordinate final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VirtualStickFlightCoordinate) */ {
 public:
  inline VirtualStickFlightCoordinate() : VirtualStickFlightCoordinate(nullptr) {}
  explicit PROTOBUF_CONSTEXPR VirtualStickFlightCoordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualStickFlightCoordinate(const VirtualStickFlightCoordinate& from);
  VirtualStickFlightCoordinate(VirtualStickFlightCoordinate&& from) noexcept
    : VirtualStickFlightCoordinate() {
    *this = ::std::move(from);
  }

  inline VirtualStickFlightCoordinate& operator=(const VirtualStickFlightCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualStickFlightCoordinate& operator=(VirtualStickFlightCoordinate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualStickFlightCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualStickFlightCoordinate* internal_default_instance() {
    return reinterpret_cast<const VirtualStickFlightCoordinate*>(
               &_VirtualStickFlightCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VirtualStickFlightCoordinate& a, VirtualStickFlightCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualStickFlightCoordinate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualStickFlightCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualStickFlightCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualStickFlightCoordinate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VirtualStickFlightCoordinate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VirtualStickFlightCoordinate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VirtualStickFlightCoordinate";
  }
  protected:
  explicit VirtualStickFlightCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VirtualStickFlightCoordinate_System System;
  static constexpr System Ground =
    VirtualStickFlightCoordinate_System_Ground;
  static constexpr System Body =
    VirtualStickFlightCoordinate_System_Body;
  static constexpr System Unknown =
    VirtualStickFlightCoordinate_System_Unknown;
  static inline bool System_IsValid(int value) {
    return VirtualStickFlightCoordinate_System_IsValid(value);
  }
  static constexpr System System_MIN =
    VirtualStickFlightCoordinate_System_System_MIN;
  static constexpr System System_MAX =
    VirtualStickFlightCoordinate_System_System_MAX;
  static constexpr int System_ARRAYSIZE =
    VirtualStickFlightCoordinate_System_System_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  System_descriptor() {
    return VirtualStickFlightCoordinate_System_descriptor();
  }
  template<typename T>
  static inline const std::string& System_Name(T enum_t_value) {
    static_assert(::std::is_same<T, System>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function System_Name.");
    return VirtualStickFlightCoordinate_System_Name(enum_t_value);
  }
  static inline bool System_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      System* value) {
    return VirtualStickFlightCoordinate_System_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VirtualStickFlightCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class VirtualStickFlightControlData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VirtualStickFlightControlData) */ {
 public:
  inline VirtualStickFlightControlData() : VirtualStickFlightControlData(nullptr) {}
  ~VirtualStickFlightControlData() override;
  explicit PROTOBUF_CONSTEXPR VirtualStickFlightControlData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualStickFlightControlData(const VirtualStickFlightControlData& from);
  VirtualStickFlightControlData(VirtualStickFlightControlData&& from) noexcept
    : VirtualStickFlightControlData() {
    *this = ::std::move(from);
  }

  inline VirtualStickFlightControlData& operator=(const VirtualStickFlightControlData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualStickFlightControlData& operator=(VirtualStickFlightControlData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualStickFlightControlData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualStickFlightControlData* internal_default_instance() {
    return reinterpret_cast<const VirtualStickFlightControlData*>(
               &_VirtualStickFlightControlData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VirtualStickFlightControlData& a, VirtualStickFlightControlData& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualStickFlightControlData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualStickFlightControlData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualStickFlightControlData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualStickFlightControlData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualStickFlightControlData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VirtualStickFlightControlData& from) {
    VirtualStickFlightControlData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualStickFlightControlData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VirtualStickFlightControlData";
  }
  protected:
  explicit VirtualStickFlightControlData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
    kRollFieldNumber = 2,
    kYawFieldNumber = 3,
    kVerticalThrottleFieldNumber = 4,
    kVerticalControlModeFieldNumber = 5,
    kRollPitchControlModeFieldNumber = 6,
    kYawControlModeFieldNumber = 7,
    kRollPitchCoordinateSystemFieldNumber = 8,
  };
  // float pitch = 1;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 2;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float yaw = 3;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float verticalThrottle = 4;
  void clear_verticalthrottle();
  float verticalthrottle() const;
  void set_verticalthrottle(float value);
  private:
  float _internal_verticalthrottle() const;
  void _internal_set_verticalthrottle(float value);
  public:

  // .DJIFRProto.Standard.VirtualStickVerticalControl.Mode verticalControlMode = 5;
  void clear_verticalcontrolmode();
  ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode verticalcontrolmode() const;
  void set_verticalcontrolmode(::DJIFRProto::Standard::VirtualStickVerticalControl_Mode value);
  private:
  ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode _internal_verticalcontrolmode() const;
  void _internal_set_verticalcontrolmode(::DJIFRProto::Standard::VirtualStickVerticalControl_Mode value);
  public:

  // .DJIFRProto.Standard.VirtualStickRollPitchControl.Mode rollPitchControlMode = 6;
  void clear_rollpitchcontrolmode();
  ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode rollpitchcontrolmode() const;
  void set_rollpitchcontrolmode(::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode value);
  private:
  ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode _internal_rollpitchcontrolmode() const;
  void _internal_set_rollpitchcontrolmode(::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode value);
  public:

  // .DJIFRProto.Standard.VirtualStickYawControl.Mode yawControlMode = 7;
  void clear_yawcontrolmode();
  ::DJIFRProto::Standard::VirtualStickYawControl_Mode yawcontrolmode() const;
  void set_yawcontrolmode(::DJIFRProto::Standard::VirtualStickYawControl_Mode value);
  private:
  ::DJIFRProto::Standard::VirtualStickYawControl_Mode _internal_yawcontrolmode() const;
  void _internal_set_yawcontrolmode(::DJIFRProto::Standard::VirtualStickYawControl_Mode value);
  public:

  // .DJIFRProto.Standard.VirtualStickFlightCoordinate.System rollPitchCoordinateSystem = 8;
  void clear_rollpitchcoordinatesystem();
  ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System rollpitchcoordinatesystem() const;
  void set_rollpitchcoordinatesystem(::DJIFRProto::Standard::VirtualStickFlightCoordinate_System value);
  private:
  ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System _internal_rollpitchcoordinatesystem() const;
  void _internal_set_rollpitchcoordinatesystem(::DJIFRProto::Standard::VirtualStickFlightCoordinate_System value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VirtualStickFlightControlData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float pitch_;
    float roll_;
    float yaw_;
    float verticalthrottle_;
    int verticalcontrolmode_;
    int rollpitchcontrolmode_;
    int yawcontrolmode_;
    int rollpitchcoordinatesystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// -------------------------------------------------------------------

class FlightControllerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.FlightControllerState) */ {
 public:
  inline FlightControllerState() : FlightControllerState(nullptr) {}
  ~FlightControllerState() override;
  explicit PROTOBUF_CONSTEXPR FlightControllerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightControllerState(const FlightControllerState& from);
  FlightControllerState(FlightControllerState&& from) noexcept
    : FlightControllerState() {
    *this = ::std::move(from);
  }

  inline FlightControllerState& operator=(const FlightControllerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightControllerState& operator=(FlightControllerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightControllerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightControllerState* internal_default_instance() {
    return reinterpret_cast<const FlightControllerState*>(
               &_FlightControllerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FlightControllerState& a, FlightControllerState& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightControllerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightControllerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightControllerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightControllerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightControllerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightControllerState& from) {
    FlightControllerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightControllerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.FlightControllerState";
  }
  protected:
  explicit FlightControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttitudeFieldNumber = 1,
    kHomeLocationCoordinateFieldNumber = 2,
    kAircraftLocationFieldNumber = 4,
    kVirtualControlDataFieldNumber = 14,
    kVelocityFieldNumber = 26,
    kTakeoffLocationAltitudeFieldNumber = 3,
    kAltitudeFieldNumber = 5,
    kFlightModeFieldNumber = 6,
    kGPSSignalLevelFieldNumber = 7,
    kSatelliteCountFieldNumber = 8,
    kRemainingFlightTimeFieldNumber = 9,
    kBatteryPercentageNeededToLandFromCurrentHeightFieldNumber = 10,
    kBatteryPercentageNeededToGoHomeFieldNumber = 11,
    kSmartRTHStateFieldNumber = 12,
    kBehaviorFieldNumber = 13,
    kIsFailsafeEnabledFieldNumber = 15,
    kAreMotorsOnFieldNumber = 16,
    kIsHomeLocationSetFieldNumber = 17,
    kIsLandingConfirmationNeededFieldNumber = 18,
    kWindWarningFieldNumber = 21,
    kCountOfFlightsFieldNumber = 22,
    kHasReachedMaxFlightHeightFieldNumber = 19,
    kHasReachedMaxFlightRadiusFieldNumber = 20,
    kIsFlyingFieldNumber = 24,
    kIsGPSBeingUsedFieldNumber = 27,
    kFlightLogIndexFieldNumber = 23,
    kSmartRTHCountdownFieldNumber = 25,
    kFlightTimeInSecondsFieldNumber = 28,
    kCumulativeFlightDistanceFieldNumber = 29,
  };
  // .DJIFRProto.Standard.Attitude attitude = 1;
  bool has_attitude() const;
  private:
  bool _internal_has_attitude() const;
  public:
  void clear_attitude();
  const ::DJIFRProto::Standard::Attitude& attitude() const;
  PROTOBUF_NODISCARD ::DJIFRProto::Standard::Attitude* release_attitude();
  ::DJIFRProto::Standard::Attitude* mutable_attitude();
  void set_allocated_attitude(::DJIFRProto::Standard::Attitude* attitude);
  private:
  const ::DJIFRProto::Standard::Attitude& _internal_attitude() const;
  ::DJIFRProto::Standard::Attitude* _internal_mutable_attitude();
  public:
  void unsafe_arena_set_allocated_attitude(
      ::DJIFRProto::Standard::Attitude* attitude);
  ::DJIFRProto::Standard::Attitude* unsafe_arena_release_attitude();

  // .DJIFRProto.Standard.LocationCoordinate2D homeLocationCoordinate = 2;
  bool has_homelocationcoordinate() const;
  private:
  bool _internal_has_homelocationcoordinate() const;
  public:
  void clear_homelocationcoordinate();
  const ::DJIFRProto::Standard::LocationCoordinate2D& homelocationcoordinate() const;
  PROTOBUF_NODISCARD ::DJIFRProto::Standard::LocationCoordinate2D* release_homelocationcoordinate();
  ::DJIFRProto::Standard::LocationCoordinate2D* mutable_homelocationcoordinate();
  void set_allocated_homelocationcoordinate(::DJIFRProto::Standard::LocationCoordinate2D* homelocationcoordinate);
  private:
  const ::DJIFRProto::Standard::LocationCoordinate2D& _internal_homelocationcoordinate() const;
  ::DJIFRProto::Standard::LocationCoordinate2D* _internal_mutable_homelocationcoordinate();
  public:
  void unsafe_arena_set_allocated_homelocationcoordinate(
      ::DJIFRProto::Standard::LocationCoordinate2D* homelocationcoordinate);
  ::DJIFRProto::Standard::LocationCoordinate2D* unsafe_arena_release_homelocationcoordinate();

  // .DJIFRProto.Standard.LocationCoordinate2D aircraftLocation = 4;
  bool has_aircraftlocation() const;
  private:
  bool _internal_has_aircraftlocation() const;
  public:
  void clear_aircraftlocation();
  const ::DJIFRProto::Standard::LocationCoordinate2D& aircraftlocation() const;
  PROTOBUF_NODISCARD ::DJIFRProto::Standard::LocationCoordinate2D* release_aircraftlocation();
  ::DJIFRProto::Standard::LocationCoordinate2D* mutable_aircraftlocation();
  void set_allocated_aircraftlocation(::DJIFRProto::Standard::LocationCoordinate2D* aircraftlocation);
  private:
  const ::DJIFRProto::Standard::LocationCoordinate2D& _internal_aircraftlocation() const;
  ::DJIFRProto::Standard::LocationCoordinate2D* _internal_mutable_aircraftlocation();
  public:
  void unsafe_arena_set_allocated_aircraftlocation(
      ::DJIFRProto::Standard::LocationCoordinate2D* aircraftlocation);
  ::DJIFRProto::Standard::LocationCoordinate2D* unsafe_arena_release_aircraftlocation();

  // .DJIFRProto.Standard.VirtualStickFlightControlData virtualControlData = 14;
  bool has_virtualcontroldata() const;
  private:
  bool _internal_has_virtualcontroldata() const;
  public:
  void clear_virtualcontroldata();
  const ::DJIFRProto::Standard::VirtualStickFlightControlData& virtualcontroldata() const;
  PROTOBUF_NODISCARD ::DJIFRProto::Standard::VirtualStickFlightControlData* release_virtualcontroldata();
  ::DJIFRProto::Standard::VirtualStickFlightControlData* mutable_virtualcontroldata();
  void set_allocated_virtualcontroldata(::DJIFRProto::Standard::VirtualStickFlightControlData* virtualcontroldata);
  private:
  const ::DJIFRProto::Standard::VirtualStickFlightControlData& _internal_virtualcontroldata() const;
  ::DJIFRProto::Standard::VirtualStickFlightControlData* _internal_mutable_virtualcontroldata();
  public:
  void unsafe_arena_set_allocated_virtualcontroldata(
      ::DJIFRProto::Standard::VirtualStickFlightControlData* virtualcontroldata);
  ::DJIFRProto::Standard::VirtualStickFlightControlData* unsafe_arena_release_virtualcontroldata();

  // .DJIFRProto.Standard.Velocity velocity = 26;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::DJIFRProto::Standard::Velocity& velocity() const;
  PROTOBUF_NODISCARD ::DJIFRProto::Standard::Velocity* release_velocity();
  ::DJIFRProto::Standard::Velocity* mutable_velocity();
  void set_allocated_velocity(::DJIFRProto::Standard::Velocity* velocity);
  private:
  const ::DJIFRProto::Standard::Velocity& _internal_velocity() const;
  ::DJIFRProto::Standard::Velocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::DJIFRProto::Standard::Velocity* velocity);
  ::DJIFRProto::Standard::Velocity* unsafe_arena_release_velocity();

  // float takeoffLocationAltitude = 3;
  void clear_takeofflocationaltitude();
  float takeofflocationaltitude() const;
  void set_takeofflocationaltitude(float value);
  private:
  float _internal_takeofflocationaltitude() const;
  void _internal_set_takeofflocationaltitude(float value);
  public:

  // float altitude = 5;
  void clear_altitude();
  float altitude() const;
  void set_altitude(float value);
  private:
  float _internal_altitude() const;
  void _internal_set_altitude(float value);
  public:

  // .DJIFRProto.Standard.FlightMode flightMode = 6;
  void clear_flightmode();
  ::DJIFRProto::Standard::FlightMode flightmode() const;
  void set_flightmode(::DJIFRProto::Standard::FlightMode value);
  private:
  ::DJIFRProto::Standard::FlightMode _internal_flightmode() const;
  void _internal_set_flightmode(::DJIFRProto::Standard::FlightMode value);
  public:

  // .DJIFRProto.Standard.GPSSignal.Level GPSSignalLevel = 7;
  void clear_gpssignallevel();
  ::DJIFRProto::Standard::GPSSignal_Level gpssignallevel() const;
  void set_gpssignallevel(::DJIFRProto::Standard::GPSSignal_Level value);
  private:
  ::DJIFRProto::Standard::GPSSignal_Level _internal_gpssignallevel() const;
  void _internal_set_gpssignallevel(::DJIFRProto::Standard::GPSSignal_Level value);
  public:

  // int32 satelliteCount = 8;
  void clear_satellitecount();
  int32_t satellitecount() const;
  void set_satellitecount(int32_t value);
  private:
  int32_t _internal_satellitecount() const;
  void _internal_set_satellitecount(int32_t value);
  public:

  // int32 remainingFlightTime = 9;
  void clear_remainingflighttime();
  int32_t remainingflighttime() const;
  void set_remainingflighttime(int32_t value);
  private:
  int32_t _internal_remainingflighttime() const;
  void _internal_set_remainingflighttime(int32_t value);
  public:

  // int32 batteryPercentageNeededToLandFromCurrentHeight = 10;
  void clear_batterypercentageneededtolandfromcurrentheight();
  int32_t batterypercentageneededtolandfromcurrentheight() const;
  void set_batterypercentageneededtolandfromcurrentheight(int32_t value);
  private:
  int32_t _internal_batterypercentageneededtolandfromcurrentheight() const;
  void _internal_set_batterypercentageneededtolandfromcurrentheight(int32_t value);
  public:

  // int32 batteryPercentageNeededToGoHome = 11;
  void clear_batterypercentageneededtogohome();
  int32_t batterypercentageneededtogohome() const;
  void set_batterypercentageneededtogohome(int32_t value);
  private:
  int32_t _internal_batterypercentageneededtogohome() const;
  void _internal_set_batterypercentageneededtogohome(int32_t value);
  public:

  // .DJIFRProto.Standard.SmartRTH.State smartRTHState = 12;
  void clear_smartrthstate();
  ::DJIFRProto::Standard::SmartRTH_State smartrthstate() const;
  void set_smartrthstate(::DJIFRProto::Standard::SmartRTH_State value);
  private:
  ::DJIFRProto::Standard::SmartRTH_State _internal_smartrthstate() const;
  void _internal_set_smartrthstate(::DJIFRProto::Standard::SmartRTH_State value);
  public:

  // .DJIFRProto.Standard.Connection.FailSafeBehavior behavior = 13;
  void clear_behavior();
  ::DJIFRProto::Standard::Connection_FailSafeBehavior behavior() const;
  void set_behavior(::DJIFRProto::Standard::Connection_FailSafeBehavior value);
  private:
  ::DJIFRProto::Standard::Connection_FailSafeBehavior _internal_behavior() const;
  void _internal_set_behavior(::DJIFRProto::Standard::Connection_FailSafeBehavior value);
  public:

  // bool isFailsafeEnabled = 15;
  void clear_isfailsafeenabled();
  bool isfailsafeenabled() const;
  void set_isfailsafeenabled(bool value);
  private:
  bool _internal_isfailsafeenabled() const;
  void _internal_set_isfailsafeenabled(bool value);
  public:

  // bool areMotorsOn = 16;
  void clear_aremotorson();
  bool aremotorson() const;
  void set_aremotorson(bool value);
  private:
  bool _internal_aremotorson() const;
  void _internal_set_aremotorson(bool value);
  public:

  // bool isHomeLocationSet = 17;
  void clear_ishomelocationset();
  bool ishomelocationset() const;
  void set_ishomelocationset(bool value);
  private:
  bool _internal_ishomelocationset() const;
  void _internal_set_ishomelocationset(bool value);
  public:

  // bool isLandingConfirmationNeeded = 18;
  void clear_islandingconfirmationneeded();
  bool islandingconfirmationneeded() const;
  void set_islandingconfirmationneeded(bool value);
  private:
  bool _internal_islandingconfirmationneeded() const;
  void _internal_set_islandingconfirmationneeded(bool value);
  public:

  // .DJIFRProto.Standard.FlightWind.Warning windWarning = 21;
  void clear_windwarning();
  ::DJIFRProto::Standard::FlightWind_Warning windwarning() const;
  void set_windwarning(::DJIFRProto::Standard::FlightWind_Warning value);
  private:
  ::DJIFRProto::Standard::FlightWind_Warning _internal_windwarning() const;
  void _internal_set_windwarning(::DJIFRProto::Standard::FlightWind_Warning value);
  public:

  // int32 countOfFlights = 22;
  void clear_countofflights();
  int32_t countofflights() const;
  void set_countofflights(int32_t value);
  private:
  int32_t _internal_countofflights() const;
  void _internal_set_countofflights(int32_t value);
  public:

  // bool hasReachedMaxFlightHeight = 19;
  void clear_hasreachedmaxflightheight();
  bool hasreachedmaxflightheight() const;
  void set_hasreachedmaxflightheight(bool value);
  private:
  bool _internal_hasreachedmaxflightheight() const;
  void _internal_set_hasreachedmaxflightheight(bool value);
  public:

  // bool hasReachedMaxFlightRadius = 20;
  void clear_hasreachedmaxflightradius();
  bool hasreachedmaxflightradius() const;
  void set_hasreachedmaxflightradius(bool value);
  private:
  bool _internal_hasreachedmaxflightradius() const;
  void _internal_set_hasreachedmaxflightradius(bool value);
  public:

  // bool isFlying = 24;
  void clear_isflying();
  bool isflying() const;
  void set_isflying(bool value);
  private:
  bool _internal_isflying() const;
  void _internal_set_isflying(bool value);
  public:

  // bool isGPSBeingUsed = 27;
  void clear_isgpsbeingused();
  bool isgpsbeingused() const;
  void set_isgpsbeingused(bool value);
  private:
  bool _internal_isgpsbeingused() const;
  void _internal_set_isgpsbeingused(bool value);
  public:

  // int32 flightLogIndex = 23;
  void clear_flightlogindex();
  int32_t flightlogindex() const;
  void set_flightlogindex(int32_t value);
  private:
  int32_t _internal_flightlogindex() const;
  void _internal_set_flightlogindex(int32_t value);
  public:

  // int32 smartRTHCountdown = 25;
  void clear_smartrthcountdown();
  int32_t smartrthcountdown() const;
  void set_smartrthcountdown(int32_t value);
  private:
  int32_t _internal_smartrthcountdown() const;
  void _internal_set_smartrthcountdown(int32_t value);
  public:

  // double flightTimeInSeconds = 28;
  void clear_flighttimeinseconds();
  double flighttimeinseconds() const;
  void set_flighttimeinseconds(double value);
  private:
  double _internal_flighttimeinseconds() const;
  void _internal_set_flighttimeinseconds(double value);
  public:

  // double cumulativeFlightDistance = 29;
  void clear_cumulativeflightdistance();
  double cumulativeflightdistance() const;
  void set_cumulativeflightdistance(double value);
  private:
  double _internal_cumulativeflightdistance() const;
  void _internal_set_cumulativeflightdistance(double value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.FlightControllerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DJIFRProto::Standard::Attitude* attitude_;
    ::DJIFRProto::Standard::LocationCoordinate2D* homelocationcoordinate_;
    ::DJIFRProto::Standard::LocationCoordinate2D* aircraftlocation_;
    ::DJIFRProto::Standard::VirtualStickFlightControlData* virtualcontroldata_;
    ::DJIFRProto::Standard::Velocity* velocity_;
    float takeofflocationaltitude_;
    float altitude_;
    int flightmode_;
    int gpssignallevel_;
    int32_t satellitecount_;
    int32_t remainingflighttime_;
    int32_t batterypercentageneededtolandfromcurrentheight_;
    int32_t batterypercentageneededtogohome_;
    int smartrthstate_;
    int behavior_;
    bool isfailsafeenabled_;
    bool aremotorson_;
    bool ishomelocationset_;
    bool islandingconfirmationneeded_;
    int windwarning_;
    int32_t countofflights_;
    bool hasreachedmaxflightheight_;
    bool hasreachedmaxflightradius_;
    bool isflying_;
    bool isgpsbeingused_;
    int32_t flightlogindex_;
    int32_t smartrthcountdown_;
    double flighttimeinseconds_;
    double cumulativeflightdistance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRFlightControllerModelProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FlightWind

// -------------------------------------------------------------------

// Connection

// -------------------------------------------------------------------

// SmartRTH

// -------------------------------------------------------------------

// VirtualStickVerticalControl

// -------------------------------------------------------------------

// VirtualStickRollPitchControl

// -------------------------------------------------------------------

// VirtualStickYawControl

// -------------------------------------------------------------------

// VirtualStickFlightCoordinate

// -------------------------------------------------------------------

// VirtualStickFlightControlData

// float pitch = 1;
inline void VirtualStickFlightControlData::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float VirtualStickFlightControlData::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float VirtualStickFlightControlData::pitch() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.pitch)
  return _internal_pitch();
}
inline void VirtualStickFlightControlData::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void VirtualStickFlightControlData::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.pitch)
}

// float roll = 2;
inline void VirtualStickFlightControlData::clear_roll() {
  _impl_.roll_ = 0;
}
inline float VirtualStickFlightControlData::_internal_roll() const {
  return _impl_.roll_;
}
inline float VirtualStickFlightControlData::roll() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.roll)
  return _internal_roll();
}
inline void VirtualStickFlightControlData::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void VirtualStickFlightControlData::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.roll)
}

// float yaw = 3;
inline void VirtualStickFlightControlData::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float VirtualStickFlightControlData::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float VirtualStickFlightControlData::yaw() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.yaw)
  return _internal_yaw();
}
inline void VirtualStickFlightControlData::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void VirtualStickFlightControlData::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.yaw)
}

// float verticalThrottle = 4;
inline void VirtualStickFlightControlData::clear_verticalthrottle() {
  _impl_.verticalthrottle_ = 0;
}
inline float VirtualStickFlightControlData::_internal_verticalthrottle() const {
  return _impl_.verticalthrottle_;
}
inline float VirtualStickFlightControlData::verticalthrottle() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.verticalThrottle)
  return _internal_verticalthrottle();
}
inline void VirtualStickFlightControlData::_internal_set_verticalthrottle(float value) {
  
  _impl_.verticalthrottle_ = value;
}
inline void VirtualStickFlightControlData::set_verticalthrottle(float value) {
  _internal_set_verticalthrottle(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.verticalThrottle)
}

// .DJIFRProto.Standard.VirtualStickVerticalControl.Mode verticalControlMode = 5;
inline void VirtualStickFlightControlData::clear_verticalcontrolmode() {
  _impl_.verticalcontrolmode_ = 0;
}
inline ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode VirtualStickFlightControlData::_internal_verticalcontrolmode() const {
  return static_cast< ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode >(_impl_.verticalcontrolmode_);
}
inline ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode VirtualStickFlightControlData::verticalcontrolmode() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.verticalControlMode)
  return _internal_verticalcontrolmode();
}
inline void VirtualStickFlightControlData::_internal_set_verticalcontrolmode(::DJIFRProto::Standard::VirtualStickVerticalControl_Mode value) {
  
  _impl_.verticalcontrolmode_ = value;
}
inline void VirtualStickFlightControlData::set_verticalcontrolmode(::DJIFRProto::Standard::VirtualStickVerticalControl_Mode value) {
  _internal_set_verticalcontrolmode(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.verticalControlMode)
}

// .DJIFRProto.Standard.VirtualStickRollPitchControl.Mode rollPitchControlMode = 6;
inline void VirtualStickFlightControlData::clear_rollpitchcontrolmode() {
  _impl_.rollpitchcontrolmode_ = 0;
}
inline ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode VirtualStickFlightControlData::_internal_rollpitchcontrolmode() const {
  return static_cast< ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode >(_impl_.rollpitchcontrolmode_);
}
inline ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode VirtualStickFlightControlData::rollpitchcontrolmode() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.rollPitchControlMode)
  return _internal_rollpitchcontrolmode();
}
inline void VirtualStickFlightControlData::_internal_set_rollpitchcontrolmode(::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode value) {
  
  _impl_.rollpitchcontrolmode_ = value;
}
inline void VirtualStickFlightControlData::set_rollpitchcontrolmode(::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode value) {
  _internal_set_rollpitchcontrolmode(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.rollPitchControlMode)
}

// .DJIFRProto.Standard.VirtualStickYawControl.Mode yawControlMode = 7;
inline void VirtualStickFlightControlData::clear_yawcontrolmode() {
  _impl_.yawcontrolmode_ = 0;
}
inline ::DJIFRProto::Standard::VirtualStickYawControl_Mode VirtualStickFlightControlData::_internal_yawcontrolmode() const {
  return static_cast< ::DJIFRProto::Standard::VirtualStickYawControl_Mode >(_impl_.yawcontrolmode_);
}
inline ::DJIFRProto::Standard::VirtualStickYawControl_Mode VirtualStickFlightControlData::yawcontrolmode() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.yawControlMode)
  return _internal_yawcontrolmode();
}
inline void VirtualStickFlightControlData::_internal_set_yawcontrolmode(::DJIFRProto::Standard::VirtualStickYawControl_Mode value) {
  
  _impl_.yawcontrolmode_ = value;
}
inline void VirtualStickFlightControlData::set_yawcontrolmode(::DJIFRProto::Standard::VirtualStickYawControl_Mode value) {
  _internal_set_yawcontrolmode(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.yawControlMode)
}

// .DJIFRProto.Standard.VirtualStickFlightCoordinate.System rollPitchCoordinateSystem = 8;
inline void VirtualStickFlightControlData::clear_rollpitchcoordinatesystem() {
  _impl_.rollpitchcoordinatesystem_ = 0;
}
inline ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System VirtualStickFlightControlData::_internal_rollpitchcoordinatesystem() const {
  return static_cast< ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System >(_impl_.rollpitchcoordinatesystem_);
}
inline ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System VirtualStickFlightControlData::rollpitchcoordinatesystem() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VirtualStickFlightControlData.rollPitchCoordinateSystem)
  return _internal_rollpitchcoordinatesystem();
}
inline void VirtualStickFlightControlData::_internal_set_rollpitchcoordinatesystem(::DJIFRProto::Standard::VirtualStickFlightCoordinate_System value) {
  
  _impl_.rollpitchcoordinatesystem_ = value;
}
inline void VirtualStickFlightControlData::set_rollpitchcoordinatesystem(::DJIFRProto::Standard::VirtualStickFlightCoordinate_System value) {
  _internal_set_rollpitchcoordinatesystem(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VirtualStickFlightControlData.rollPitchCoordinateSystem)
}

// -------------------------------------------------------------------

// FlightControllerState

// .DJIFRProto.Standard.Attitude attitude = 1;
inline bool FlightControllerState::_internal_has_attitude() const {
  return this != internal_default_instance() && _impl_.attitude_ != nullptr;
}
inline bool FlightControllerState::has_attitude() const {
  return _internal_has_attitude();
}
inline const ::DJIFRProto::Standard::Attitude& FlightControllerState::_internal_attitude() const {
  const ::DJIFRProto::Standard::Attitude* p = _impl_.attitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::DJIFRProto::Standard::Attitude&>(
      ::DJIFRProto::Standard::_Attitude_default_instance_);
}
inline const ::DJIFRProto::Standard::Attitude& FlightControllerState::attitude() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.attitude)
  return _internal_attitude();
}
inline void FlightControllerState::unsafe_arena_set_allocated_attitude(
    ::DJIFRProto::Standard::Attitude* attitude) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attitude_);
  }
  _impl_.attitude_ = attitude;
  if (attitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DJIFRProto.Standard.FlightControllerState.attitude)
}
inline ::DJIFRProto::Standard::Attitude* FlightControllerState::release_attitude() {
  
  ::DJIFRProto::Standard::Attitude* temp = _impl_.attitude_;
  _impl_.attitude_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DJIFRProto::Standard::Attitude* FlightControllerState::unsafe_arena_release_attitude() {
  // @@protoc_insertion_point(field_release:DJIFRProto.Standard.FlightControllerState.attitude)
  
  ::DJIFRProto::Standard::Attitude* temp = _impl_.attitude_;
  _impl_.attitude_ = nullptr;
  return temp;
}
inline ::DJIFRProto::Standard::Attitude* FlightControllerState::_internal_mutable_attitude() {
  
  if (_impl_.attitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::DJIFRProto::Standard::Attitude>(GetArenaForAllocation());
    _impl_.attitude_ = p;
  }
  return _impl_.attitude_;
}
inline ::DJIFRProto::Standard::Attitude* FlightControllerState::mutable_attitude() {
  ::DJIFRProto::Standard::Attitude* _msg = _internal_mutable_attitude();
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.FlightControllerState.attitude)
  return _msg;
}
inline void FlightControllerState::set_allocated_attitude(::DJIFRProto::Standard::Attitude* attitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attitude_);
  }
  if (attitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attitude));
    if (message_arena != submessage_arena) {
      attitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attitude, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attitude_ = attitude;
  // @@protoc_insertion_point(field_set_allocated:DJIFRProto.Standard.FlightControllerState.attitude)
}

// .DJIFRProto.Standard.LocationCoordinate2D homeLocationCoordinate = 2;
inline bool FlightControllerState::_internal_has_homelocationcoordinate() const {
  return this != internal_default_instance() && _impl_.homelocationcoordinate_ != nullptr;
}
inline bool FlightControllerState::has_homelocationcoordinate() const {
  return _internal_has_homelocationcoordinate();
}
inline const ::DJIFRProto::Standard::LocationCoordinate2D& FlightControllerState::_internal_homelocationcoordinate() const {
  const ::DJIFRProto::Standard::LocationCoordinate2D* p = _impl_.homelocationcoordinate_;
  return p != nullptr ? *p : reinterpret_cast<const ::DJIFRProto::Standard::LocationCoordinate2D&>(
      ::DJIFRProto::Standard::_LocationCoordinate2D_default_instance_);
}
inline const ::DJIFRProto::Standard::LocationCoordinate2D& FlightControllerState::homelocationcoordinate() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.homeLocationCoordinate)
  return _internal_homelocationcoordinate();
}
inline void FlightControllerState::unsafe_arena_set_allocated_homelocationcoordinate(
    ::DJIFRProto::Standard::LocationCoordinate2D* homelocationcoordinate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.homelocationcoordinate_);
  }
  _impl_.homelocationcoordinate_ = homelocationcoordinate;
  if (homelocationcoordinate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DJIFRProto.Standard.FlightControllerState.homeLocationCoordinate)
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::release_homelocationcoordinate() {
  
  ::DJIFRProto::Standard::LocationCoordinate2D* temp = _impl_.homelocationcoordinate_;
  _impl_.homelocationcoordinate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::unsafe_arena_release_homelocationcoordinate() {
  // @@protoc_insertion_point(field_release:DJIFRProto.Standard.FlightControllerState.homeLocationCoordinate)
  
  ::DJIFRProto::Standard::LocationCoordinate2D* temp = _impl_.homelocationcoordinate_;
  _impl_.homelocationcoordinate_ = nullptr;
  return temp;
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::_internal_mutable_homelocationcoordinate() {
  
  if (_impl_.homelocationcoordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::DJIFRProto::Standard::LocationCoordinate2D>(GetArenaForAllocation());
    _impl_.homelocationcoordinate_ = p;
  }
  return _impl_.homelocationcoordinate_;
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::mutable_homelocationcoordinate() {
  ::DJIFRProto::Standard::LocationCoordinate2D* _msg = _internal_mutable_homelocationcoordinate();
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.FlightControllerState.homeLocationCoordinate)
  return _msg;
}
inline void FlightControllerState::set_allocated_homelocationcoordinate(::DJIFRProto::Standard::LocationCoordinate2D* homelocationcoordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.homelocationcoordinate_);
  }
  if (homelocationcoordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(homelocationcoordinate));
    if (message_arena != submessage_arena) {
      homelocationcoordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, homelocationcoordinate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.homelocationcoordinate_ = homelocationcoordinate;
  // @@protoc_insertion_point(field_set_allocated:DJIFRProto.Standard.FlightControllerState.homeLocationCoordinate)
}

// float takeoffLocationAltitude = 3;
inline void FlightControllerState::clear_takeofflocationaltitude() {
  _impl_.takeofflocationaltitude_ = 0;
}
inline float FlightControllerState::_internal_takeofflocationaltitude() const {
  return _impl_.takeofflocationaltitude_;
}
inline float FlightControllerState::takeofflocationaltitude() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.takeoffLocationAltitude)
  return _internal_takeofflocationaltitude();
}
inline void FlightControllerState::_internal_set_takeofflocationaltitude(float value) {
  
  _impl_.takeofflocationaltitude_ = value;
}
inline void FlightControllerState::set_takeofflocationaltitude(float value) {
  _internal_set_takeofflocationaltitude(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.takeoffLocationAltitude)
}

// .DJIFRProto.Standard.LocationCoordinate2D aircraftLocation = 4;
inline bool FlightControllerState::_internal_has_aircraftlocation() const {
  return this != internal_default_instance() && _impl_.aircraftlocation_ != nullptr;
}
inline bool FlightControllerState::has_aircraftlocation() const {
  return _internal_has_aircraftlocation();
}
inline const ::DJIFRProto::Standard::LocationCoordinate2D& FlightControllerState::_internal_aircraftlocation() const {
  const ::DJIFRProto::Standard::LocationCoordinate2D* p = _impl_.aircraftlocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::DJIFRProto::Standard::LocationCoordinate2D&>(
      ::DJIFRProto::Standard::_LocationCoordinate2D_default_instance_);
}
inline const ::DJIFRProto::Standard::LocationCoordinate2D& FlightControllerState::aircraftlocation() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.aircraftLocation)
  return _internal_aircraftlocation();
}
inline void FlightControllerState::unsafe_arena_set_allocated_aircraftlocation(
    ::DJIFRProto::Standard::LocationCoordinate2D* aircraftlocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aircraftlocation_);
  }
  _impl_.aircraftlocation_ = aircraftlocation;
  if (aircraftlocation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DJIFRProto.Standard.FlightControllerState.aircraftLocation)
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::release_aircraftlocation() {
  
  ::DJIFRProto::Standard::LocationCoordinate2D* temp = _impl_.aircraftlocation_;
  _impl_.aircraftlocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::unsafe_arena_release_aircraftlocation() {
  // @@protoc_insertion_point(field_release:DJIFRProto.Standard.FlightControllerState.aircraftLocation)
  
  ::DJIFRProto::Standard::LocationCoordinate2D* temp = _impl_.aircraftlocation_;
  _impl_.aircraftlocation_ = nullptr;
  return temp;
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::_internal_mutable_aircraftlocation() {
  
  if (_impl_.aircraftlocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::DJIFRProto::Standard::LocationCoordinate2D>(GetArenaForAllocation());
    _impl_.aircraftlocation_ = p;
  }
  return _impl_.aircraftlocation_;
}
inline ::DJIFRProto::Standard::LocationCoordinate2D* FlightControllerState::mutable_aircraftlocation() {
  ::DJIFRProto::Standard::LocationCoordinate2D* _msg = _internal_mutable_aircraftlocation();
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.FlightControllerState.aircraftLocation)
  return _msg;
}
inline void FlightControllerState::set_allocated_aircraftlocation(::DJIFRProto::Standard::LocationCoordinate2D* aircraftlocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aircraftlocation_);
  }
  if (aircraftlocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aircraftlocation));
    if (message_arena != submessage_arena) {
      aircraftlocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aircraftlocation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.aircraftlocation_ = aircraftlocation;
  // @@protoc_insertion_point(field_set_allocated:DJIFRProto.Standard.FlightControllerState.aircraftLocation)
}

// float altitude = 5;
inline void FlightControllerState::clear_altitude() {
  _impl_.altitude_ = 0;
}
inline float FlightControllerState::_internal_altitude() const {
  return _impl_.altitude_;
}
inline float FlightControllerState::altitude() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.altitude)
  return _internal_altitude();
}
inline void FlightControllerState::_internal_set_altitude(float value) {
  
  _impl_.altitude_ = value;
}
inline void FlightControllerState::set_altitude(float value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.altitude)
}

// .DJIFRProto.Standard.FlightMode flightMode = 6;
inline void FlightControllerState::clear_flightmode() {
  _impl_.flightmode_ = 0;
}
inline ::DJIFRProto::Standard::FlightMode FlightControllerState::_internal_flightmode() const {
  return static_cast< ::DJIFRProto::Standard::FlightMode >(_impl_.flightmode_);
}
inline ::DJIFRProto::Standard::FlightMode FlightControllerState::flightmode() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.flightMode)
  return _internal_flightmode();
}
inline void FlightControllerState::_internal_set_flightmode(::DJIFRProto::Standard::FlightMode value) {
  
  _impl_.flightmode_ = value;
}
inline void FlightControllerState::set_flightmode(::DJIFRProto::Standard::FlightMode value) {
  _internal_set_flightmode(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.flightMode)
}

// .DJIFRProto.Standard.GPSSignal.Level GPSSignalLevel = 7;
inline void FlightControllerState::clear_gpssignallevel() {
  _impl_.gpssignallevel_ = 0;
}
inline ::DJIFRProto::Standard::GPSSignal_Level FlightControllerState::_internal_gpssignallevel() const {
  return static_cast< ::DJIFRProto::Standard::GPSSignal_Level >(_impl_.gpssignallevel_);
}
inline ::DJIFRProto::Standard::GPSSignal_Level FlightControllerState::gpssignallevel() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.GPSSignalLevel)
  return _internal_gpssignallevel();
}
inline void FlightControllerState::_internal_set_gpssignallevel(::DJIFRProto::Standard::GPSSignal_Level value) {
  
  _impl_.gpssignallevel_ = value;
}
inline void FlightControllerState::set_gpssignallevel(::DJIFRProto::Standard::GPSSignal_Level value) {
  _internal_set_gpssignallevel(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.GPSSignalLevel)
}

// int32 satelliteCount = 8;
inline void FlightControllerState::clear_satellitecount() {
  _impl_.satellitecount_ = 0;
}
inline int32_t FlightControllerState::_internal_satellitecount() const {
  return _impl_.satellitecount_;
}
inline int32_t FlightControllerState::satellitecount() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.satelliteCount)
  return _internal_satellitecount();
}
inline void FlightControllerState::_internal_set_satellitecount(int32_t value) {
  
  _impl_.satellitecount_ = value;
}
inline void FlightControllerState::set_satellitecount(int32_t value) {
  _internal_set_satellitecount(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.satelliteCount)
}

// int32 remainingFlightTime = 9;
inline void FlightControllerState::clear_remainingflighttime() {
  _impl_.remainingflighttime_ = 0;
}
inline int32_t FlightControllerState::_internal_remainingflighttime() const {
  return _impl_.remainingflighttime_;
}
inline int32_t FlightControllerState::remainingflighttime() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.remainingFlightTime)
  return _internal_remainingflighttime();
}
inline void FlightControllerState::_internal_set_remainingflighttime(int32_t value) {
  
  _impl_.remainingflighttime_ = value;
}
inline void FlightControllerState::set_remainingflighttime(int32_t value) {
  _internal_set_remainingflighttime(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.remainingFlightTime)
}

// int32 batteryPercentageNeededToLandFromCurrentHeight = 10;
inline void FlightControllerState::clear_batterypercentageneededtolandfromcurrentheight() {
  _impl_.batterypercentageneededtolandfromcurrentheight_ = 0;
}
inline int32_t FlightControllerState::_internal_batterypercentageneededtolandfromcurrentheight() const {
  return _impl_.batterypercentageneededtolandfromcurrentheight_;
}
inline int32_t FlightControllerState::batterypercentageneededtolandfromcurrentheight() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.batteryPercentageNeededToLandFromCurrentHeight)
  return _internal_batterypercentageneededtolandfromcurrentheight();
}
inline void FlightControllerState::_internal_set_batterypercentageneededtolandfromcurrentheight(int32_t value) {
  
  _impl_.batterypercentageneededtolandfromcurrentheight_ = value;
}
inline void FlightControllerState::set_batterypercentageneededtolandfromcurrentheight(int32_t value) {
  _internal_set_batterypercentageneededtolandfromcurrentheight(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.batteryPercentageNeededToLandFromCurrentHeight)
}

// int32 batteryPercentageNeededToGoHome = 11;
inline void FlightControllerState::clear_batterypercentageneededtogohome() {
  _impl_.batterypercentageneededtogohome_ = 0;
}
inline int32_t FlightControllerState::_internal_batterypercentageneededtogohome() const {
  return _impl_.batterypercentageneededtogohome_;
}
inline int32_t FlightControllerState::batterypercentageneededtogohome() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.batteryPercentageNeededToGoHome)
  return _internal_batterypercentageneededtogohome();
}
inline void FlightControllerState::_internal_set_batterypercentageneededtogohome(int32_t value) {
  
  _impl_.batterypercentageneededtogohome_ = value;
}
inline void FlightControllerState::set_batterypercentageneededtogohome(int32_t value) {
  _internal_set_batterypercentageneededtogohome(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.batteryPercentageNeededToGoHome)
}

// .DJIFRProto.Standard.SmartRTH.State smartRTHState = 12;
inline void FlightControllerState::clear_smartrthstate() {
  _impl_.smartrthstate_ = 0;
}
inline ::DJIFRProto::Standard::SmartRTH_State FlightControllerState::_internal_smartrthstate() const {
  return static_cast< ::DJIFRProto::Standard::SmartRTH_State >(_impl_.smartrthstate_);
}
inline ::DJIFRProto::Standard::SmartRTH_State FlightControllerState::smartrthstate() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.smartRTHState)
  return _internal_smartrthstate();
}
inline void FlightControllerState::_internal_set_smartrthstate(::DJIFRProto::Standard::SmartRTH_State value) {
  
  _impl_.smartrthstate_ = value;
}
inline void FlightControllerState::set_smartrthstate(::DJIFRProto::Standard::SmartRTH_State value) {
  _internal_set_smartrthstate(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.smartRTHState)
}

// .DJIFRProto.Standard.Connection.FailSafeBehavior behavior = 13;
inline void FlightControllerState::clear_behavior() {
  _impl_.behavior_ = 0;
}
inline ::DJIFRProto::Standard::Connection_FailSafeBehavior FlightControllerState::_internal_behavior() const {
  return static_cast< ::DJIFRProto::Standard::Connection_FailSafeBehavior >(_impl_.behavior_);
}
inline ::DJIFRProto::Standard::Connection_FailSafeBehavior FlightControllerState::behavior() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.behavior)
  return _internal_behavior();
}
inline void FlightControllerState::_internal_set_behavior(::DJIFRProto::Standard::Connection_FailSafeBehavior value) {
  
  _impl_.behavior_ = value;
}
inline void FlightControllerState::set_behavior(::DJIFRProto::Standard::Connection_FailSafeBehavior value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.behavior)
}

// .DJIFRProto.Standard.VirtualStickFlightControlData virtualControlData = 14;
inline bool FlightControllerState::_internal_has_virtualcontroldata() const {
  return this != internal_default_instance() && _impl_.virtualcontroldata_ != nullptr;
}
inline bool FlightControllerState::has_virtualcontroldata() const {
  return _internal_has_virtualcontroldata();
}
inline void FlightControllerState::clear_virtualcontroldata() {
  if (GetArenaForAllocation() == nullptr && _impl_.virtualcontroldata_ != nullptr) {
    delete _impl_.virtualcontroldata_;
  }
  _impl_.virtualcontroldata_ = nullptr;
}
inline const ::DJIFRProto::Standard::VirtualStickFlightControlData& FlightControllerState::_internal_virtualcontroldata() const {
  const ::DJIFRProto::Standard::VirtualStickFlightControlData* p = _impl_.virtualcontroldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::DJIFRProto::Standard::VirtualStickFlightControlData&>(
      ::DJIFRProto::Standard::_VirtualStickFlightControlData_default_instance_);
}
inline const ::DJIFRProto::Standard::VirtualStickFlightControlData& FlightControllerState::virtualcontroldata() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.virtualControlData)
  return _internal_virtualcontroldata();
}
inline void FlightControllerState::unsafe_arena_set_allocated_virtualcontroldata(
    ::DJIFRProto::Standard::VirtualStickFlightControlData* virtualcontroldata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.virtualcontroldata_);
  }
  _impl_.virtualcontroldata_ = virtualcontroldata;
  if (virtualcontroldata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DJIFRProto.Standard.FlightControllerState.virtualControlData)
}
inline ::DJIFRProto::Standard::VirtualStickFlightControlData* FlightControllerState::release_virtualcontroldata() {
  
  ::DJIFRProto::Standard::VirtualStickFlightControlData* temp = _impl_.virtualcontroldata_;
  _impl_.virtualcontroldata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DJIFRProto::Standard::VirtualStickFlightControlData* FlightControllerState::unsafe_arena_release_virtualcontroldata() {
  // @@protoc_insertion_point(field_release:DJIFRProto.Standard.FlightControllerState.virtualControlData)
  
  ::DJIFRProto::Standard::VirtualStickFlightControlData* temp = _impl_.virtualcontroldata_;
  _impl_.virtualcontroldata_ = nullptr;
  return temp;
}
inline ::DJIFRProto::Standard::VirtualStickFlightControlData* FlightControllerState::_internal_mutable_virtualcontroldata() {
  
  if (_impl_.virtualcontroldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::DJIFRProto::Standard::VirtualStickFlightControlData>(GetArenaForAllocation());
    _impl_.virtualcontroldata_ = p;
  }
  return _impl_.virtualcontroldata_;
}
inline ::DJIFRProto::Standard::VirtualStickFlightControlData* FlightControllerState::mutable_virtualcontroldata() {
  ::DJIFRProto::Standard::VirtualStickFlightControlData* _msg = _internal_mutable_virtualcontroldata();
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.FlightControllerState.virtualControlData)
  return _msg;
}
inline void FlightControllerState::set_allocated_virtualcontroldata(::DJIFRProto::Standard::VirtualStickFlightControlData* virtualcontroldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.virtualcontroldata_;
  }
  if (virtualcontroldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(virtualcontroldata);
    if (message_arena != submessage_arena) {
      virtualcontroldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtualcontroldata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.virtualcontroldata_ = virtualcontroldata;
  // @@protoc_insertion_point(field_set_allocated:DJIFRProto.Standard.FlightControllerState.virtualControlData)
}

// bool isFailsafeEnabled = 15;
inline void FlightControllerState::clear_isfailsafeenabled() {
  _impl_.isfailsafeenabled_ = false;
}
inline bool FlightControllerState::_internal_isfailsafeenabled() const {
  return _impl_.isfailsafeenabled_;
}
inline bool FlightControllerState::isfailsafeenabled() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.isFailsafeEnabled)
  return _internal_isfailsafeenabled();
}
inline void FlightControllerState::_internal_set_isfailsafeenabled(bool value) {
  
  _impl_.isfailsafeenabled_ = value;
}
inline void FlightControllerState::set_isfailsafeenabled(bool value) {
  _internal_set_isfailsafeenabled(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.isFailsafeEnabled)
}

// bool areMotorsOn = 16;
inline void FlightControllerState::clear_aremotorson() {
  _impl_.aremotorson_ = false;
}
inline bool FlightControllerState::_internal_aremotorson() const {
  return _impl_.aremotorson_;
}
inline bool FlightControllerState::aremotorson() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.areMotorsOn)
  return _internal_aremotorson();
}
inline void FlightControllerState::_internal_set_aremotorson(bool value) {
  
  _impl_.aremotorson_ = value;
}
inline void FlightControllerState::set_aremotorson(bool value) {
  _internal_set_aremotorson(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.areMotorsOn)
}

// bool isHomeLocationSet = 17;
inline void FlightControllerState::clear_ishomelocationset() {
  _impl_.ishomelocationset_ = false;
}
inline bool FlightControllerState::_internal_ishomelocationset() const {
  return _impl_.ishomelocationset_;
}
inline bool FlightControllerState::ishomelocationset() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.isHomeLocationSet)
  return _internal_ishomelocationset();
}
inline void FlightControllerState::_internal_set_ishomelocationset(bool value) {
  
  _impl_.ishomelocationset_ = value;
}
inline void FlightControllerState::set_ishomelocationset(bool value) {
  _internal_set_ishomelocationset(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.isHomeLocationSet)
}

// bool isLandingConfirmationNeeded = 18;
inline void FlightControllerState::clear_islandingconfirmationneeded() {
  _impl_.islandingconfirmationneeded_ = false;
}
inline bool FlightControllerState::_internal_islandingconfirmationneeded() const {
  return _impl_.islandingconfirmationneeded_;
}
inline bool FlightControllerState::islandingconfirmationneeded() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.isLandingConfirmationNeeded)
  return _internal_islandingconfirmationneeded();
}
inline void FlightControllerState::_internal_set_islandingconfirmationneeded(bool value) {
  
  _impl_.islandingconfirmationneeded_ = value;
}
inline void FlightControllerState::set_islandingconfirmationneeded(bool value) {
  _internal_set_islandingconfirmationneeded(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.isLandingConfirmationNeeded)
}

// bool hasReachedMaxFlightHeight = 19;
inline void FlightControllerState::clear_hasreachedmaxflightheight() {
  _impl_.hasreachedmaxflightheight_ = false;
}
inline bool FlightControllerState::_internal_hasreachedmaxflightheight() const {
  return _impl_.hasreachedmaxflightheight_;
}
inline bool FlightControllerState::hasreachedmaxflightheight() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.hasReachedMaxFlightHeight)
  return _internal_hasreachedmaxflightheight();
}
inline void FlightControllerState::_internal_set_hasreachedmaxflightheight(bool value) {
  
  _impl_.hasreachedmaxflightheight_ = value;
}
inline void FlightControllerState::set_hasreachedmaxflightheight(bool value) {
  _internal_set_hasreachedmaxflightheight(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.hasReachedMaxFlightHeight)
}

// bool hasReachedMaxFlightRadius = 20;
inline void FlightControllerState::clear_hasreachedmaxflightradius() {
  _impl_.hasreachedmaxflightradius_ = false;
}
inline bool FlightControllerState::_internal_hasreachedmaxflightradius() const {
  return _impl_.hasreachedmaxflightradius_;
}
inline bool FlightControllerState::hasreachedmaxflightradius() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.hasReachedMaxFlightRadius)
  return _internal_hasreachedmaxflightradius();
}
inline void FlightControllerState::_internal_set_hasreachedmaxflightradius(bool value) {
  
  _impl_.hasreachedmaxflightradius_ = value;
}
inline void FlightControllerState::set_hasreachedmaxflightradius(bool value) {
  _internal_set_hasreachedmaxflightradius(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.hasReachedMaxFlightRadius)
}

// .DJIFRProto.Standard.FlightWind.Warning windWarning = 21;
inline void FlightControllerState::clear_windwarning() {
  _impl_.windwarning_ = 0;
}
inline ::DJIFRProto::Standard::FlightWind_Warning FlightControllerState::_internal_windwarning() const {
  return static_cast< ::DJIFRProto::Standard::FlightWind_Warning >(_impl_.windwarning_);
}
inline ::DJIFRProto::Standard::FlightWind_Warning FlightControllerState::windwarning() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.windWarning)
  return _internal_windwarning();
}
inline void FlightControllerState::_internal_set_windwarning(::DJIFRProto::Standard::FlightWind_Warning value) {
  
  _impl_.windwarning_ = value;
}
inline void FlightControllerState::set_windwarning(::DJIFRProto::Standard::FlightWind_Warning value) {
  _internal_set_windwarning(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.windWarning)
}

// int32 countOfFlights = 22;
inline void FlightControllerState::clear_countofflights() {
  _impl_.countofflights_ = 0;
}
inline int32_t FlightControllerState::_internal_countofflights() const {
  return _impl_.countofflights_;
}
inline int32_t FlightControllerState::countofflights() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.countOfFlights)
  return _internal_countofflights();
}
inline void FlightControllerState::_internal_set_countofflights(int32_t value) {
  
  _impl_.countofflights_ = value;
}
inline void FlightControllerState::set_countofflights(int32_t value) {
  _internal_set_countofflights(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.countOfFlights)
}

// int32 flightLogIndex = 23;
inline void FlightControllerState::clear_flightlogindex() {
  _impl_.flightlogindex_ = 0;
}
inline int32_t FlightControllerState::_internal_flightlogindex() const {
  return _impl_.flightlogindex_;
}
inline int32_t FlightControllerState::flightlogindex() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.flightLogIndex)
  return _internal_flightlogindex();
}
inline void FlightControllerState::_internal_set_flightlogindex(int32_t value) {
  
  _impl_.flightlogindex_ = value;
}
inline void FlightControllerState::set_flightlogindex(int32_t value) {
  _internal_set_flightlogindex(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.flightLogIndex)
}

// bool isFlying = 24;
inline void FlightControllerState::clear_isflying() {
  _impl_.isflying_ = false;
}
inline bool FlightControllerState::_internal_isflying() const {
  return _impl_.isflying_;
}
inline bool FlightControllerState::isflying() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.isFlying)
  return _internal_isflying();
}
inline void FlightControllerState::_internal_set_isflying(bool value) {
  
  _impl_.isflying_ = value;
}
inline void FlightControllerState::set_isflying(bool value) {
  _internal_set_isflying(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.isFlying)
}

// int32 smartRTHCountdown = 25;
inline void FlightControllerState::clear_smartrthcountdown() {
  _impl_.smartrthcountdown_ = 0;
}
inline int32_t FlightControllerState::_internal_smartrthcountdown() const {
  return _impl_.smartrthcountdown_;
}
inline int32_t FlightControllerState::smartrthcountdown() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.smartRTHCountdown)
  return _internal_smartrthcountdown();
}
inline void FlightControllerState::_internal_set_smartrthcountdown(int32_t value) {
  
  _impl_.smartrthcountdown_ = value;
}
inline void FlightControllerState::set_smartrthcountdown(int32_t value) {
  _internal_set_smartrthcountdown(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.smartRTHCountdown)
}

// .DJIFRProto.Standard.Velocity velocity = 26;
inline bool FlightControllerState::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool FlightControllerState::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::DJIFRProto::Standard::Velocity& FlightControllerState::_internal_velocity() const {
  const ::DJIFRProto::Standard::Velocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::DJIFRProto::Standard::Velocity&>(
      ::DJIFRProto::Standard::_Velocity_default_instance_);
}
inline const ::DJIFRProto::Standard::Velocity& FlightControllerState::velocity() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.velocity)
  return _internal_velocity();
}
inline void FlightControllerState::unsafe_arena_set_allocated_velocity(
    ::DJIFRProto::Standard::Velocity* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DJIFRProto.Standard.FlightControllerState.velocity)
}
inline ::DJIFRProto::Standard::Velocity* FlightControllerState::release_velocity() {
  
  ::DJIFRProto::Standard::Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DJIFRProto::Standard::Velocity* FlightControllerState::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:DJIFRProto.Standard.FlightControllerState.velocity)
  
  ::DJIFRProto::Standard::Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::DJIFRProto::Standard::Velocity* FlightControllerState::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::DJIFRProto::Standard::Velocity>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::DJIFRProto::Standard::Velocity* FlightControllerState::mutable_velocity() {
  ::DJIFRProto::Standard::Velocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.FlightControllerState.velocity)
  return _msg;
}
inline void FlightControllerState::set_allocated_velocity(::DJIFRProto::Standard::Velocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:DJIFRProto.Standard.FlightControllerState.velocity)
}

// bool isGPSBeingUsed = 27;
inline void FlightControllerState::clear_isgpsbeingused() {
  _impl_.isgpsbeingused_ = false;
}
inline bool FlightControllerState::_internal_isgpsbeingused() const {
  return _impl_.isgpsbeingused_;
}
inline bool FlightControllerState::isgpsbeingused() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.isGPSBeingUsed)
  return _internal_isgpsbeingused();
}
inline void FlightControllerState::_internal_set_isgpsbeingused(bool value) {
  
  _impl_.isgpsbeingused_ = value;
}
inline void FlightControllerState::set_isgpsbeingused(bool value) {
  _internal_set_isgpsbeingused(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.isGPSBeingUsed)
}

// double flightTimeInSeconds = 28;
inline void FlightControllerState::clear_flighttimeinseconds() {
  _impl_.flighttimeinseconds_ = 0;
}
inline double FlightControllerState::_internal_flighttimeinseconds() const {
  return _impl_.flighttimeinseconds_;
}
inline double FlightControllerState::flighttimeinseconds() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.flightTimeInSeconds)
  return _internal_flighttimeinseconds();
}
inline void FlightControllerState::_internal_set_flighttimeinseconds(double value) {
  
  _impl_.flighttimeinseconds_ = value;
}
inline void FlightControllerState::set_flighttimeinseconds(double value) {
  _internal_set_flighttimeinseconds(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.flightTimeInSeconds)
}

// double cumulativeFlightDistance = 29;
inline void FlightControllerState::clear_cumulativeflightdistance() {
  _impl_.cumulativeflightdistance_ = 0;
}
inline double FlightControllerState::_internal_cumulativeflightdistance() const {
  return _impl_.cumulativeflightdistance_;
}
inline double FlightControllerState::cumulativeflightdistance() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.FlightControllerState.cumulativeFlightDistance)
  return _internal_cumulativeflightdistance();
}
inline void FlightControllerState::_internal_set_cumulativeflightdistance(double value) {
  
  _impl_.cumulativeflightdistance_ = value;
}
inline void FlightControllerState::set_cumulativeflightdistance(double value) {
  _internal_set_cumulativeflightdistance(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.FlightControllerState.cumulativeFlightDistance)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Standard
}  // namespace DJIFRProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DJIFRProto::Standard::FlightWind_Warning> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::FlightWind_Warning>() {
  return ::DJIFRProto::Standard::FlightWind_Warning_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::Connection_FailSafeBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::Connection_FailSafeBehavior>() {
  return ::DJIFRProto::Standard::Connection_FailSafeBehavior_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::SmartRTH_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::SmartRTH_State>() {
  return ::DJIFRProto::Standard::SmartRTH_State_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode>() {
  return ::DJIFRProto::Standard::VirtualStickVerticalControl_Mode_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode>() {
  return ::DJIFRProto::Standard::VirtualStickRollPitchControl_Mode_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::VirtualStickYawControl_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::VirtualStickYawControl_Mode>() {
  return ::DJIFRProto::Standard::VirtualStickYawControl_Mode_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System>() {
  return ::DJIFRProto::Standard::VirtualStickFlightCoordinate_System_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::FlightMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::FlightMode>() {
  return ::DJIFRProto::Standard::FlightMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_FRFlightControllerModelProto_2eproto
