// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FRVisionModelProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_FRVisionModelProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_FRVisionModelProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_FRVisionModelProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_FRVisionModelProto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_FRVisionModelProto_2eproto;
namespace DJIFRProto {
namespace Standard {
class ObstacleDetectionSector;
struct ObstacleDetectionSectorDefaultTypeInternal;
extern ObstacleDetectionSectorDefaultTypeInternal _ObstacleDetectionSector_default_instance_;
class Vision;
struct VisionDefaultTypeInternal;
extern VisionDefaultTypeInternal _Vision_default_instance_;
class VisionControlState;
struct VisionControlStateDefaultTypeInternal;
extern VisionControlStateDefaultTypeInternal _VisionControlState_default_instance_;
class VisionDetectionState;
struct VisionDetectionStateDefaultTypeInternal;
extern VisionDetectionStateDefaultTypeInternal _VisionDetectionState_default_instance_;
class VisionState;
struct VisionStateDefaultTypeInternal;
extern VisionStateDefaultTypeInternal _VisionState_default_instance_;
class VisionState_DetectionStateMapEntry_DoNotUse;
struct VisionState_DetectionStateMapEntry_DoNotUseDefaultTypeInternal;
extern VisionState_DetectionStateMapEntry_DoNotUseDefaultTypeInternal _VisionState_DetectionStateMapEntry_DoNotUse_default_instance_;
}  // namespace Standard
}  // namespace DJIFRProto
PROTOBUF_NAMESPACE_OPEN
template<> ::DJIFRProto::Standard::ObstacleDetectionSector* Arena::CreateMaybeMessage<::DJIFRProto::Standard::ObstacleDetectionSector>(Arena*);
template<> ::DJIFRProto::Standard::Vision* Arena::CreateMaybeMessage<::DJIFRProto::Standard::Vision>(Arena*);
template<> ::DJIFRProto::Standard::VisionControlState* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VisionControlState>(Arena*);
template<> ::DJIFRProto::Standard::VisionDetectionState* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VisionDetectionState>(Arena*);
template<> ::DJIFRProto::Standard::VisionState* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VisionState>(Arena*);
template<> ::DJIFRProto::Standard::VisionState_DetectionStateMapEntry_DoNotUse* Arena::CreateMaybeMessage<::DJIFRProto::Standard::VisionState_DetectionStateMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DJIFRProto {
namespace Standard {

enum Vision_ObstacleDetectionSectorWarning : int {
  Vision_ObstacleDetectionSectorWarning_DetectionInvalid = 0,
  Vision_ObstacleDetectionSectorWarning_DetectionSafe = 1,
  Vision_ObstacleDetectionSectorWarning_Warning = 2,
  Vision_ObstacleDetectionSectorWarning_Danger = 3,
  Vision_ObstacleDetectionSectorWarning_Vision_ObstacleDetectionSectorWarning_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Vision_ObstacleDetectionSectorWarning_Vision_ObstacleDetectionSectorWarning_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Vision_ObstacleDetectionSectorWarning_IsValid(int value);
constexpr Vision_ObstacleDetectionSectorWarning Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_MIN = Vision_ObstacleDetectionSectorWarning_DetectionInvalid;
constexpr Vision_ObstacleDetectionSectorWarning Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_MAX = Vision_ObstacleDetectionSectorWarning_Danger;
constexpr int Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_ARRAYSIZE = Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vision_ObstacleDetectionSectorWarning_descriptor();
template<typename T>
inline const std::string& Vision_ObstacleDetectionSectorWarning_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vision_ObstacleDetectionSectorWarning>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vision_ObstacleDetectionSectorWarning_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vision_ObstacleDetectionSectorWarning_descriptor(), enum_t_value);
}
inline bool Vision_ObstacleDetectionSectorWarning_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Vision_ObstacleDetectionSectorWarning* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vision_ObstacleDetectionSectorWarning>(
    Vision_ObstacleDetectionSectorWarning_descriptor(), name, value);
}
enum Vision_VisionSensorPosition : int {
  Vision_VisionSensorPosition_Nose = 0,
  Vision_VisionSensorPosition_Tail = 1,
  Vision_VisionSensorPosition_Right = 2,
  Vision_VisionSensorPosition_Left = 3,
  Vision_VisionSensorPosition_PositionUnknown = 4,
  Vision_VisionSensorPosition_Vision_VisionSensorPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Vision_VisionSensorPosition_Vision_VisionSensorPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Vision_VisionSensorPosition_IsValid(int value);
constexpr Vision_VisionSensorPosition Vision_VisionSensorPosition_VisionSensorPosition_MIN = Vision_VisionSensorPosition_Nose;
constexpr Vision_VisionSensorPosition Vision_VisionSensorPosition_VisionSensorPosition_MAX = Vision_VisionSensorPosition_PositionUnknown;
constexpr int Vision_VisionSensorPosition_VisionSensorPosition_ARRAYSIZE = Vision_VisionSensorPosition_VisionSensorPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vision_VisionSensorPosition_descriptor();
template<typename T>
inline const std::string& Vision_VisionSensorPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vision_VisionSensorPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vision_VisionSensorPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vision_VisionSensorPosition_descriptor(), enum_t_value);
}
inline bool Vision_VisionSensorPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Vision_VisionSensorPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vision_VisionSensorPosition>(
    Vision_VisionSensorPosition_descriptor(), name, value);
}
enum Vision_VisionSystemWarning : int {
  Vision_VisionSystemWarning_VisionSystemInvalid = 0,
  Vision_VisionSystemWarning_VisionSystemSafe = 1,
  Vision_VisionSystemWarning_Dangerous = 2,
  Vision_VisionSystemWarning_VisionSystemUnknown = 3,
  Vision_VisionSystemWarning_Vision_VisionSystemWarning_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Vision_VisionSystemWarning_Vision_VisionSystemWarning_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Vision_VisionSystemWarning_IsValid(int value);
constexpr Vision_VisionSystemWarning Vision_VisionSystemWarning_VisionSystemWarning_MIN = Vision_VisionSystemWarning_VisionSystemInvalid;
constexpr Vision_VisionSystemWarning Vision_VisionSystemWarning_VisionSystemWarning_MAX = Vision_VisionSystemWarning_VisionSystemUnknown;
constexpr int Vision_VisionSystemWarning_VisionSystemWarning_ARRAYSIZE = Vision_VisionSystemWarning_VisionSystemWarning_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vision_VisionSystemWarning_descriptor();
template<typename T>
inline const std::string& Vision_VisionSystemWarning_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vision_VisionSystemWarning>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vision_VisionSystemWarning_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vision_VisionSystemWarning_descriptor(), enum_t_value);
}
inline bool Vision_VisionSystemWarning_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Vision_VisionSystemWarning* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vision_VisionSystemWarning>(
    Vision_VisionSystemWarning_descriptor(), name, value);
}
// ===================================================================

class Vision final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.Vision) */ {
 public:
  inline Vision() : Vision(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Vision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vision(const Vision& from);
  Vision(Vision&& from) noexcept
    : Vision() {
    *this = ::std::move(from);
  }

  inline Vision& operator=(const Vision& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vision& operator=(Vision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vision& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vision* internal_default_instance() {
    return reinterpret_cast<const Vision*>(
               &_Vision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vision& a, Vision& b) {
    a.Swap(&b);
  }
  inline void Swap(Vision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vision>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Vision& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Vision& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.Vision";
  }
  protected:
  explicit Vision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vision_ObstacleDetectionSectorWarning ObstacleDetectionSectorWarning;
  static constexpr ObstacleDetectionSectorWarning DetectionInvalid =
    Vision_ObstacleDetectionSectorWarning_DetectionInvalid;
  static constexpr ObstacleDetectionSectorWarning DetectionSafe =
    Vision_ObstacleDetectionSectorWarning_DetectionSafe;
  static constexpr ObstacleDetectionSectorWarning Warning =
    Vision_ObstacleDetectionSectorWarning_Warning;
  static constexpr ObstacleDetectionSectorWarning Danger =
    Vision_ObstacleDetectionSectorWarning_Danger;
  static inline bool ObstacleDetectionSectorWarning_IsValid(int value) {
    return Vision_ObstacleDetectionSectorWarning_IsValid(value);
  }
  static constexpr ObstacleDetectionSectorWarning ObstacleDetectionSectorWarning_MIN =
    Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_MIN;
  static constexpr ObstacleDetectionSectorWarning ObstacleDetectionSectorWarning_MAX =
    Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_MAX;
  static constexpr int ObstacleDetectionSectorWarning_ARRAYSIZE =
    Vision_ObstacleDetectionSectorWarning_ObstacleDetectionSectorWarning_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ObstacleDetectionSectorWarning_descriptor() {
    return Vision_ObstacleDetectionSectorWarning_descriptor();
  }
  template<typename T>
  static inline const std::string& ObstacleDetectionSectorWarning_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ObstacleDetectionSectorWarning>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ObstacleDetectionSectorWarning_Name.");
    return Vision_ObstacleDetectionSectorWarning_Name(enum_t_value);
  }
  static inline bool ObstacleDetectionSectorWarning_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ObstacleDetectionSectorWarning* value) {
    return Vision_ObstacleDetectionSectorWarning_Parse(name, value);
  }

  typedef Vision_VisionSensorPosition VisionSensorPosition;
  static constexpr VisionSensorPosition Nose =
    Vision_VisionSensorPosition_Nose;
  static constexpr VisionSensorPosition Tail =
    Vision_VisionSensorPosition_Tail;
  static constexpr VisionSensorPosition Right =
    Vision_VisionSensorPosition_Right;
  static constexpr VisionSensorPosition Left =
    Vision_VisionSensorPosition_Left;
  static constexpr VisionSensorPosition PositionUnknown =
    Vision_VisionSensorPosition_PositionUnknown;
  static inline bool VisionSensorPosition_IsValid(int value) {
    return Vision_VisionSensorPosition_IsValid(value);
  }
  static constexpr VisionSensorPosition VisionSensorPosition_MIN =
    Vision_VisionSensorPosition_VisionSensorPosition_MIN;
  static constexpr VisionSensorPosition VisionSensorPosition_MAX =
    Vision_VisionSensorPosition_VisionSensorPosition_MAX;
  static constexpr int VisionSensorPosition_ARRAYSIZE =
    Vision_VisionSensorPosition_VisionSensorPosition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VisionSensorPosition_descriptor() {
    return Vision_VisionSensorPosition_descriptor();
  }
  template<typename T>
  static inline const std::string& VisionSensorPosition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VisionSensorPosition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VisionSensorPosition_Name.");
    return Vision_VisionSensorPosition_Name(enum_t_value);
  }
  static inline bool VisionSensorPosition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VisionSensorPosition* value) {
    return Vision_VisionSensorPosition_Parse(name, value);
  }

  typedef Vision_VisionSystemWarning VisionSystemWarning;
  static constexpr VisionSystemWarning VisionSystemInvalid =
    Vision_VisionSystemWarning_VisionSystemInvalid;
  static constexpr VisionSystemWarning VisionSystemSafe =
    Vision_VisionSystemWarning_VisionSystemSafe;
  static constexpr VisionSystemWarning Dangerous =
    Vision_VisionSystemWarning_Dangerous;
  static constexpr VisionSystemWarning VisionSystemUnknown =
    Vision_VisionSystemWarning_VisionSystemUnknown;
  static inline bool VisionSystemWarning_IsValid(int value) {
    return Vision_VisionSystemWarning_IsValid(value);
  }
  static constexpr VisionSystemWarning VisionSystemWarning_MIN =
    Vision_VisionSystemWarning_VisionSystemWarning_MIN;
  static constexpr VisionSystemWarning VisionSystemWarning_MAX =
    Vision_VisionSystemWarning_VisionSystemWarning_MAX;
  static constexpr int VisionSystemWarning_ARRAYSIZE =
    Vision_VisionSystemWarning_VisionSystemWarning_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VisionSystemWarning_descriptor() {
    return Vision_VisionSystemWarning_descriptor();
  }
  template<typename T>
  static inline const std::string& VisionSystemWarning_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VisionSystemWarning>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VisionSystemWarning_Name.");
    return Vision_VisionSystemWarning_Name(enum_t_value);
  }
  static inline bool VisionSystemWarning_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VisionSystemWarning* value) {
    return Vision_VisionSystemWarning_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.Vision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_FRVisionModelProto_2eproto;
};
// -------------------------------------------------------------------

class VisionControlState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VisionControlState) */ {
 public:
  inline VisionControlState() : VisionControlState(nullptr) {}
  ~VisionControlState() override;
  explicit PROTOBUF_CONSTEXPR VisionControlState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionControlState(const VisionControlState& from);
  VisionControlState(VisionControlState&& from) noexcept
    : VisionControlState() {
    *this = ::std::move(from);
  }

  inline VisionControlState& operator=(const VisionControlState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionControlState& operator=(VisionControlState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionControlState& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionControlState* internal_default_instance() {
    return reinterpret_cast<const VisionControlState*>(
               &_VisionControlState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VisionControlState& a, VisionControlState& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionControlState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionControlState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionControlState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionControlState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionControlState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionControlState& from) {
    VisionControlState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionControlState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VisionControlState";
  }
  protected:
  explicit VisionControlState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAscentLimitedByObstacleFieldNumber = 1,
    kIsAvoidingActiveObstacleCollisionFieldNumber = 2,
    kIsBrakingFieldNumber = 3,
    kIsPerformingPrecisionLandingFieldNumber = 4,
  };
  // bool isAscentLimitedByObstacle = 1;
  void clear_isascentlimitedbyobstacle();
  bool isascentlimitedbyobstacle() const;
  void set_isascentlimitedbyobstacle(bool value);
  private:
  bool _internal_isascentlimitedbyobstacle() const;
  void _internal_set_isascentlimitedbyobstacle(bool value);
  public:

  // bool isAvoidingActiveObstacleCollision = 2;
  void clear_isavoidingactiveobstaclecollision();
  bool isavoidingactiveobstaclecollision() const;
  void set_isavoidingactiveobstaclecollision(bool value);
  private:
  bool _internal_isavoidingactiveobstaclecollision() const;
  void _internal_set_isavoidingactiveobstaclecollision(bool value);
  public:

  // bool isBraking = 3;
  void clear_isbraking();
  bool isbraking() const;
  void set_isbraking(bool value);
  private:
  bool _internal_isbraking() const;
  void _internal_set_isbraking(bool value);
  public:

  // bool isPerformingPrecisionLanding = 4;
  void clear_isperformingprecisionlanding();
  bool isperformingprecisionlanding() const;
  void set_isperformingprecisionlanding(bool value);
  private:
  bool _internal_isperformingprecisionlanding() const;
  void _internal_set_isperformingprecisionlanding(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VisionControlState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isascentlimitedbyobstacle_;
    bool isavoidingactiveobstaclecollision_;
    bool isbraking_;
    bool isperformingprecisionlanding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRVisionModelProto_2eproto;
};
// -------------------------------------------------------------------

class ObstacleDetectionSector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.ObstacleDetectionSector) */ {
 public:
  inline ObstacleDetectionSector() : ObstacleDetectionSector(nullptr) {}
  ~ObstacleDetectionSector() override;
  explicit PROTOBUF_CONSTEXPR ObstacleDetectionSector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleDetectionSector(const ObstacleDetectionSector& from);
  ObstacleDetectionSector(ObstacleDetectionSector&& from) noexcept
    : ObstacleDetectionSector() {
    *this = ::std::move(from);
  }

  inline ObstacleDetectionSector& operator=(const ObstacleDetectionSector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleDetectionSector& operator=(ObstacleDetectionSector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleDetectionSector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleDetectionSector* internal_default_instance() {
    return reinterpret_cast<const ObstacleDetectionSector*>(
               &_ObstacleDetectionSector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ObstacleDetectionSector& a, ObstacleDetectionSector& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleDetectionSector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleDetectionSector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleDetectionSector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleDetectionSector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleDetectionSector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObstacleDetectionSector& from) {
    ObstacleDetectionSector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleDetectionSector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.ObstacleDetectionSector";
  }
  protected:
  explicit ObstacleDetectionSector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleDistanceInMetersFieldNumber = 1,
    kWarningLevelFieldNumber = 2,
  };
  // double obstacleDistanceInMeters = 1;
  void clear_obstacledistanceinmeters();
  double obstacledistanceinmeters() const;
  void set_obstacledistanceinmeters(double value);
  private:
  double _internal_obstacledistanceinmeters() const;
  void _internal_set_obstacledistanceinmeters(double value);
  public:

  // .DJIFRProto.Standard.Vision.ObstacleDetectionSectorWarning warningLevel = 2;
  void clear_warninglevel();
  ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning warninglevel() const;
  void set_warninglevel(::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning value);
  private:
  ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning _internal_warninglevel() const;
  void _internal_set_warninglevel(::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.ObstacleDetectionSector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double obstacledistanceinmeters_;
    int warninglevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRVisionModelProto_2eproto;
};
// -------------------------------------------------------------------

class VisionDetectionState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VisionDetectionState) */ {
 public:
  inline VisionDetectionState() : VisionDetectionState(nullptr) {}
  ~VisionDetectionState() override;
  explicit PROTOBUF_CONSTEXPR VisionDetectionState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionDetectionState(const VisionDetectionState& from);
  VisionDetectionState(VisionDetectionState&& from) noexcept
    : VisionDetectionState() {
    *this = ::std::move(from);
  }

  inline VisionDetectionState& operator=(const VisionDetectionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionDetectionState& operator=(VisionDetectionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionDetectionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionDetectionState* internal_default_instance() {
    return reinterpret_cast<const VisionDetectionState*>(
               &_VisionDetectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VisionDetectionState& a, VisionDetectionState& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionDetectionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionDetectionState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionDetectionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionDetectionState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionDetectionState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionDetectionState& from) {
    VisionDetectionState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionDetectionState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VisionDetectionState";
  }
  protected:
  explicit VisionDetectionState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionSectorsFieldNumber = 5,
    kPositionFieldNumber = 1,
    kIsSensorBeingUsedFieldNumber = 2,
    kObstacleDistanceInMetersFieldNumber = 4,
    kSystemWarningFieldNumber = 3,
  };
  // repeated .DJIFRProto.Standard.ObstacleDetectionSector detectionSectors = 5;
  int detectionsectors_size() const;
  private:
  int _internal_detectionsectors_size() const;
  public:
  void clear_detectionsectors();
  ::DJIFRProto::Standard::ObstacleDetectionSector* mutable_detectionsectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DJIFRProto::Standard::ObstacleDetectionSector >*
      mutable_detectionsectors();
  private:
  const ::DJIFRProto::Standard::ObstacleDetectionSector& _internal_detectionsectors(int index) const;
  ::DJIFRProto::Standard::ObstacleDetectionSector* _internal_add_detectionsectors();
  public:
  const ::DJIFRProto::Standard::ObstacleDetectionSector& detectionsectors(int index) const;
  ::DJIFRProto::Standard::ObstacleDetectionSector* add_detectionsectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DJIFRProto::Standard::ObstacleDetectionSector >&
      detectionsectors() const;

  // .DJIFRProto.Standard.Vision.VisionSensorPosition position = 1;
  void clear_position();
  ::DJIFRProto::Standard::Vision_VisionSensorPosition position() const;
  void set_position(::DJIFRProto::Standard::Vision_VisionSensorPosition value);
  private:
  ::DJIFRProto::Standard::Vision_VisionSensorPosition _internal_position() const;
  void _internal_set_position(::DJIFRProto::Standard::Vision_VisionSensorPosition value);
  public:

  // bool isSensorBeingUsed = 2;
  void clear_issensorbeingused();
  bool issensorbeingused() const;
  void set_issensorbeingused(bool value);
  private:
  bool _internal_issensorbeingused() const;
  void _internal_set_issensorbeingused(bool value);
  public:

  // double obstacleDistanceInMeters = 4;
  void clear_obstacledistanceinmeters();
  double obstacledistanceinmeters() const;
  void set_obstacledistanceinmeters(double value);
  private:
  double _internal_obstacledistanceinmeters() const;
  void _internal_set_obstacledistanceinmeters(double value);
  public:

  // .DJIFRProto.Standard.Vision.VisionSystemWarning systemWarning = 3;
  void clear_systemwarning();
  ::DJIFRProto::Standard::Vision_VisionSystemWarning systemwarning() const;
  void set_systemwarning(::DJIFRProto::Standard::Vision_VisionSystemWarning value);
  private:
  ::DJIFRProto::Standard::Vision_VisionSystemWarning _internal_systemwarning() const;
  void _internal_set_systemwarning(::DJIFRProto::Standard::Vision_VisionSystemWarning value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VisionDetectionState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DJIFRProto::Standard::ObstacleDetectionSector > detectionsectors_;
    int position_;
    bool issensorbeingused_;
    double obstacledistanceinmeters_;
    int systemwarning_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRVisionModelProto_2eproto;
};
// -------------------------------------------------------------------

class VisionState_DetectionStateMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VisionState_DetectionStateMapEntry_DoNotUse, 
    int32_t, ::DJIFRProto::Standard::VisionDetectionState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VisionState_DetectionStateMapEntry_DoNotUse, 
    int32_t, ::DJIFRProto::Standard::VisionDetectionState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  VisionState_DetectionStateMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR VisionState_DetectionStateMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit VisionState_DetectionStateMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const VisionState_DetectionStateMapEntry_DoNotUse& other);
  static const VisionState_DetectionStateMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const VisionState_DetectionStateMapEntry_DoNotUse*>(&_VisionState_DetectionStateMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_FRVisionModelProto_2eproto;
};

// -------------------------------------------------------------------

class VisionState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DJIFRProto.Standard.VisionState) */ {
 public:
  inline VisionState() : VisionState(nullptr) {}
  ~VisionState() override;
  explicit PROTOBUF_CONSTEXPR VisionState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionState(const VisionState& from);
  VisionState(VisionState&& from) noexcept
    : VisionState() {
    *this = ::std::move(from);
  }

  inline VisionState& operator=(const VisionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionState& operator=(VisionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionState* internal_default_instance() {
    return reinterpret_cast<const VisionState*>(
               &_VisionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VisionState& a, VisionState& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionState& from) {
    VisionState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DJIFRProto.Standard.VisionState";
  }
  protected:
  explicit VisionState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDetectionStateMapFieldNumber = 3,
    kControlStateFieldNumber = 2,
    kCollisionAvoidanceEnabledFieldNumber = 1,
  };
  // map<int32, .DJIFRProto.Standard.VisionDetectionState> detectionStateMap = 3;
  int detectionstatemap_size() const;
  private:
  int _internal_detectionstatemap_size() const;
  public:
  void clear_detectionstatemap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >&
      _internal_detectionstatemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >*
      _internal_mutable_detectionstatemap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >&
      detectionstatemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >*
      mutable_detectionstatemap();

  // .DJIFRProto.Standard.VisionControlState controlState = 2;
  bool has_controlstate() const;
  private:
  bool _internal_has_controlstate() const;
  public:
  void clear_controlstate();
  const ::DJIFRProto::Standard::VisionControlState& controlstate() const;
  PROTOBUF_NODISCARD ::DJIFRProto::Standard::VisionControlState* release_controlstate();
  ::DJIFRProto::Standard::VisionControlState* mutable_controlstate();
  void set_allocated_controlstate(::DJIFRProto::Standard::VisionControlState* controlstate);
  private:
  const ::DJIFRProto::Standard::VisionControlState& _internal_controlstate() const;
  ::DJIFRProto::Standard::VisionControlState* _internal_mutable_controlstate();
  public:
  void unsafe_arena_set_allocated_controlstate(
      ::DJIFRProto::Standard::VisionControlState* controlstate);
  ::DJIFRProto::Standard::VisionControlState* unsafe_arena_release_controlstate();

  // bool collisionAvoidanceEnabled = 1;
  void clear_collisionavoidanceenabled();
  bool collisionavoidanceenabled() const;
  void set_collisionavoidanceenabled(bool value);
  private:
  bool _internal_collisionavoidanceenabled() const;
  void _internal_set_collisionavoidanceenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DJIFRProto.Standard.VisionState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        VisionState_DetectionStateMapEntry_DoNotUse,
        int32_t, ::DJIFRProto::Standard::VisionDetectionState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> detectionstatemap_;
    ::DJIFRProto::Standard::VisionControlState* controlstate_;
    bool collisionavoidanceenabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FRVisionModelProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vision

// -------------------------------------------------------------------

// VisionControlState

// bool isAscentLimitedByObstacle = 1;
inline void VisionControlState::clear_isascentlimitedbyobstacle() {
  _impl_.isascentlimitedbyobstacle_ = false;
}
inline bool VisionControlState::_internal_isascentlimitedbyobstacle() const {
  return _impl_.isascentlimitedbyobstacle_;
}
inline bool VisionControlState::isascentlimitedbyobstacle() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionControlState.isAscentLimitedByObstacle)
  return _internal_isascentlimitedbyobstacle();
}
inline void VisionControlState::_internal_set_isascentlimitedbyobstacle(bool value) {
  
  _impl_.isascentlimitedbyobstacle_ = value;
}
inline void VisionControlState::set_isascentlimitedbyobstacle(bool value) {
  _internal_set_isascentlimitedbyobstacle(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionControlState.isAscentLimitedByObstacle)
}

// bool isAvoidingActiveObstacleCollision = 2;
inline void VisionControlState::clear_isavoidingactiveobstaclecollision() {
  _impl_.isavoidingactiveobstaclecollision_ = false;
}
inline bool VisionControlState::_internal_isavoidingactiveobstaclecollision() const {
  return _impl_.isavoidingactiveobstaclecollision_;
}
inline bool VisionControlState::isavoidingactiveobstaclecollision() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionControlState.isAvoidingActiveObstacleCollision)
  return _internal_isavoidingactiveobstaclecollision();
}
inline void VisionControlState::_internal_set_isavoidingactiveobstaclecollision(bool value) {
  
  _impl_.isavoidingactiveobstaclecollision_ = value;
}
inline void VisionControlState::set_isavoidingactiveobstaclecollision(bool value) {
  _internal_set_isavoidingactiveobstaclecollision(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionControlState.isAvoidingActiveObstacleCollision)
}

// bool isBraking = 3;
inline void VisionControlState::clear_isbraking() {
  _impl_.isbraking_ = false;
}
inline bool VisionControlState::_internal_isbraking() const {
  return _impl_.isbraking_;
}
inline bool VisionControlState::isbraking() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionControlState.isBraking)
  return _internal_isbraking();
}
inline void VisionControlState::_internal_set_isbraking(bool value) {
  
  _impl_.isbraking_ = value;
}
inline void VisionControlState::set_isbraking(bool value) {
  _internal_set_isbraking(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionControlState.isBraking)
}

// bool isPerformingPrecisionLanding = 4;
inline void VisionControlState::clear_isperformingprecisionlanding() {
  _impl_.isperformingprecisionlanding_ = false;
}
inline bool VisionControlState::_internal_isperformingprecisionlanding() const {
  return _impl_.isperformingprecisionlanding_;
}
inline bool VisionControlState::isperformingprecisionlanding() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionControlState.isPerformingPrecisionLanding)
  return _internal_isperformingprecisionlanding();
}
inline void VisionControlState::_internal_set_isperformingprecisionlanding(bool value) {
  
  _impl_.isperformingprecisionlanding_ = value;
}
inline void VisionControlState::set_isperformingprecisionlanding(bool value) {
  _internal_set_isperformingprecisionlanding(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionControlState.isPerformingPrecisionLanding)
}

// -------------------------------------------------------------------

// ObstacleDetectionSector

// double obstacleDistanceInMeters = 1;
inline void ObstacleDetectionSector::clear_obstacledistanceinmeters() {
  _impl_.obstacledistanceinmeters_ = 0;
}
inline double ObstacleDetectionSector::_internal_obstacledistanceinmeters() const {
  return _impl_.obstacledistanceinmeters_;
}
inline double ObstacleDetectionSector::obstacledistanceinmeters() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.ObstacleDetectionSector.obstacleDistanceInMeters)
  return _internal_obstacledistanceinmeters();
}
inline void ObstacleDetectionSector::_internal_set_obstacledistanceinmeters(double value) {
  
  _impl_.obstacledistanceinmeters_ = value;
}
inline void ObstacleDetectionSector::set_obstacledistanceinmeters(double value) {
  _internal_set_obstacledistanceinmeters(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.ObstacleDetectionSector.obstacleDistanceInMeters)
}

// .DJIFRProto.Standard.Vision.ObstacleDetectionSectorWarning warningLevel = 2;
inline void ObstacleDetectionSector::clear_warninglevel() {
  _impl_.warninglevel_ = 0;
}
inline ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning ObstacleDetectionSector::_internal_warninglevel() const {
  return static_cast< ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning >(_impl_.warninglevel_);
}
inline ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning ObstacleDetectionSector::warninglevel() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.ObstacleDetectionSector.warningLevel)
  return _internal_warninglevel();
}
inline void ObstacleDetectionSector::_internal_set_warninglevel(::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning value) {
  
  _impl_.warninglevel_ = value;
}
inline void ObstacleDetectionSector::set_warninglevel(::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning value) {
  _internal_set_warninglevel(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.ObstacleDetectionSector.warningLevel)
}

// -------------------------------------------------------------------

// VisionDetectionState

// .DJIFRProto.Standard.Vision.VisionSensorPosition position = 1;
inline void VisionDetectionState::clear_position() {
  _impl_.position_ = 0;
}
inline ::DJIFRProto::Standard::Vision_VisionSensorPosition VisionDetectionState::_internal_position() const {
  return static_cast< ::DJIFRProto::Standard::Vision_VisionSensorPosition >(_impl_.position_);
}
inline ::DJIFRProto::Standard::Vision_VisionSensorPosition VisionDetectionState::position() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionDetectionState.position)
  return _internal_position();
}
inline void VisionDetectionState::_internal_set_position(::DJIFRProto::Standard::Vision_VisionSensorPosition value) {
  
  _impl_.position_ = value;
}
inline void VisionDetectionState::set_position(::DJIFRProto::Standard::Vision_VisionSensorPosition value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionDetectionState.position)
}

// bool isSensorBeingUsed = 2;
inline void VisionDetectionState::clear_issensorbeingused() {
  _impl_.issensorbeingused_ = false;
}
inline bool VisionDetectionState::_internal_issensorbeingused() const {
  return _impl_.issensorbeingused_;
}
inline bool VisionDetectionState::issensorbeingused() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionDetectionState.isSensorBeingUsed)
  return _internal_issensorbeingused();
}
inline void VisionDetectionState::_internal_set_issensorbeingused(bool value) {
  
  _impl_.issensorbeingused_ = value;
}
inline void VisionDetectionState::set_issensorbeingused(bool value) {
  _internal_set_issensorbeingused(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionDetectionState.isSensorBeingUsed)
}

// .DJIFRProto.Standard.Vision.VisionSystemWarning systemWarning = 3;
inline void VisionDetectionState::clear_systemwarning() {
  _impl_.systemwarning_ = 0;
}
inline ::DJIFRProto::Standard::Vision_VisionSystemWarning VisionDetectionState::_internal_systemwarning() const {
  return static_cast< ::DJIFRProto::Standard::Vision_VisionSystemWarning >(_impl_.systemwarning_);
}
inline ::DJIFRProto::Standard::Vision_VisionSystemWarning VisionDetectionState::systemwarning() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionDetectionState.systemWarning)
  return _internal_systemwarning();
}
inline void VisionDetectionState::_internal_set_systemwarning(::DJIFRProto::Standard::Vision_VisionSystemWarning value) {
  
  _impl_.systemwarning_ = value;
}
inline void VisionDetectionState::set_systemwarning(::DJIFRProto::Standard::Vision_VisionSystemWarning value) {
  _internal_set_systemwarning(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionDetectionState.systemWarning)
}

// double obstacleDistanceInMeters = 4;
inline void VisionDetectionState::clear_obstacledistanceinmeters() {
  _impl_.obstacledistanceinmeters_ = 0;
}
inline double VisionDetectionState::_internal_obstacledistanceinmeters() const {
  return _impl_.obstacledistanceinmeters_;
}
inline double VisionDetectionState::obstacledistanceinmeters() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionDetectionState.obstacleDistanceInMeters)
  return _internal_obstacledistanceinmeters();
}
inline void VisionDetectionState::_internal_set_obstacledistanceinmeters(double value) {
  
  _impl_.obstacledistanceinmeters_ = value;
}
inline void VisionDetectionState::set_obstacledistanceinmeters(double value) {
  _internal_set_obstacledistanceinmeters(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionDetectionState.obstacleDistanceInMeters)
}

// repeated .DJIFRProto.Standard.ObstacleDetectionSector detectionSectors = 5;
inline int VisionDetectionState::_internal_detectionsectors_size() const {
  return _impl_.detectionsectors_.size();
}
inline int VisionDetectionState::detectionsectors_size() const {
  return _internal_detectionsectors_size();
}
inline void VisionDetectionState::clear_detectionsectors() {
  _impl_.detectionsectors_.Clear();
}
inline ::DJIFRProto::Standard::ObstacleDetectionSector* VisionDetectionState::mutable_detectionsectors(int index) {
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.VisionDetectionState.detectionSectors)
  return _impl_.detectionsectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DJIFRProto::Standard::ObstacleDetectionSector >*
VisionDetectionState::mutable_detectionsectors() {
  // @@protoc_insertion_point(field_mutable_list:DJIFRProto.Standard.VisionDetectionState.detectionSectors)
  return &_impl_.detectionsectors_;
}
inline const ::DJIFRProto::Standard::ObstacleDetectionSector& VisionDetectionState::_internal_detectionsectors(int index) const {
  return _impl_.detectionsectors_.Get(index);
}
inline const ::DJIFRProto::Standard::ObstacleDetectionSector& VisionDetectionState::detectionsectors(int index) const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionDetectionState.detectionSectors)
  return _internal_detectionsectors(index);
}
inline ::DJIFRProto::Standard::ObstacleDetectionSector* VisionDetectionState::_internal_add_detectionsectors() {
  return _impl_.detectionsectors_.Add();
}
inline ::DJIFRProto::Standard::ObstacleDetectionSector* VisionDetectionState::add_detectionsectors() {
  ::DJIFRProto::Standard::ObstacleDetectionSector* _add = _internal_add_detectionsectors();
  // @@protoc_insertion_point(field_add:DJIFRProto.Standard.VisionDetectionState.detectionSectors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DJIFRProto::Standard::ObstacleDetectionSector >&
VisionDetectionState::detectionsectors() const {
  // @@protoc_insertion_point(field_list:DJIFRProto.Standard.VisionDetectionState.detectionSectors)
  return _impl_.detectionsectors_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VisionState

// bool collisionAvoidanceEnabled = 1;
inline void VisionState::clear_collisionavoidanceenabled() {
  _impl_.collisionavoidanceenabled_ = false;
}
inline bool VisionState::_internal_collisionavoidanceenabled() const {
  return _impl_.collisionavoidanceenabled_;
}
inline bool VisionState::collisionavoidanceenabled() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionState.collisionAvoidanceEnabled)
  return _internal_collisionavoidanceenabled();
}
inline void VisionState::_internal_set_collisionavoidanceenabled(bool value) {
  
  _impl_.collisionavoidanceenabled_ = value;
}
inline void VisionState::set_collisionavoidanceenabled(bool value) {
  _internal_set_collisionavoidanceenabled(value);
  // @@protoc_insertion_point(field_set:DJIFRProto.Standard.VisionState.collisionAvoidanceEnabled)
}

// .DJIFRProto.Standard.VisionControlState controlState = 2;
inline bool VisionState::_internal_has_controlstate() const {
  return this != internal_default_instance() && _impl_.controlstate_ != nullptr;
}
inline bool VisionState::has_controlstate() const {
  return _internal_has_controlstate();
}
inline void VisionState::clear_controlstate() {
  if (GetArenaForAllocation() == nullptr && _impl_.controlstate_ != nullptr) {
    delete _impl_.controlstate_;
  }
  _impl_.controlstate_ = nullptr;
}
inline const ::DJIFRProto::Standard::VisionControlState& VisionState::_internal_controlstate() const {
  const ::DJIFRProto::Standard::VisionControlState* p = _impl_.controlstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::DJIFRProto::Standard::VisionControlState&>(
      ::DJIFRProto::Standard::_VisionControlState_default_instance_);
}
inline const ::DJIFRProto::Standard::VisionControlState& VisionState::controlstate() const {
  // @@protoc_insertion_point(field_get:DJIFRProto.Standard.VisionState.controlState)
  return _internal_controlstate();
}
inline void VisionState::unsafe_arena_set_allocated_controlstate(
    ::DJIFRProto::Standard::VisionControlState* controlstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlstate_);
  }
  _impl_.controlstate_ = controlstate;
  if (controlstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DJIFRProto.Standard.VisionState.controlState)
}
inline ::DJIFRProto::Standard::VisionControlState* VisionState::release_controlstate() {
  
  ::DJIFRProto::Standard::VisionControlState* temp = _impl_.controlstate_;
  _impl_.controlstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DJIFRProto::Standard::VisionControlState* VisionState::unsafe_arena_release_controlstate() {
  // @@protoc_insertion_point(field_release:DJIFRProto.Standard.VisionState.controlState)
  
  ::DJIFRProto::Standard::VisionControlState* temp = _impl_.controlstate_;
  _impl_.controlstate_ = nullptr;
  return temp;
}
inline ::DJIFRProto::Standard::VisionControlState* VisionState::_internal_mutable_controlstate() {
  
  if (_impl_.controlstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::DJIFRProto::Standard::VisionControlState>(GetArenaForAllocation());
    _impl_.controlstate_ = p;
  }
  return _impl_.controlstate_;
}
inline ::DJIFRProto::Standard::VisionControlState* VisionState::mutable_controlstate() {
  ::DJIFRProto::Standard::VisionControlState* _msg = _internal_mutable_controlstate();
  // @@protoc_insertion_point(field_mutable:DJIFRProto.Standard.VisionState.controlState)
  return _msg;
}
inline void VisionState::set_allocated_controlstate(::DJIFRProto::Standard::VisionControlState* controlstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.controlstate_;
  }
  if (controlstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(controlstate);
    if (message_arena != submessage_arena) {
      controlstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlstate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.controlstate_ = controlstate;
  // @@protoc_insertion_point(field_set_allocated:DJIFRProto.Standard.VisionState.controlState)
}

// map<int32, .DJIFRProto.Standard.VisionDetectionState> detectionStateMap = 3;
inline int VisionState::_internal_detectionstatemap_size() const {
  return _impl_.detectionstatemap_.size();
}
inline int VisionState::detectionstatemap_size() const {
  return _internal_detectionstatemap_size();
}
inline void VisionState::clear_detectionstatemap() {
  _impl_.detectionstatemap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >&
VisionState::_internal_detectionstatemap() const {
  return _impl_.detectionstatemap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >&
VisionState::detectionstatemap() const {
  // @@protoc_insertion_point(field_map:DJIFRProto.Standard.VisionState.detectionStateMap)
  return _internal_detectionstatemap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >*
VisionState::_internal_mutable_detectionstatemap() {
  return _impl_.detectionstatemap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::DJIFRProto::Standard::VisionDetectionState >*
VisionState::mutable_detectionstatemap() {
  // @@protoc_insertion_point(field_mutable_map:DJIFRProto.Standard.VisionState.detectionStateMap)
  return _internal_mutable_detectionstatemap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Standard
}  // namespace DJIFRProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning>() {
  return ::DJIFRProto::Standard::Vision_ObstacleDetectionSectorWarning_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::Vision_VisionSensorPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::Vision_VisionSensorPosition>() {
  return ::DJIFRProto::Standard::Vision_VisionSensorPosition_descriptor();
}
template <> struct is_proto_enum< ::DJIFRProto::Standard::Vision_VisionSystemWarning> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DJIFRProto::Standard::Vision_VisionSystemWarning>() {
  return ::DJIFRProto::Standard::Vision_VisionSystemWarning_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_FRVisionModelProto_2eproto
